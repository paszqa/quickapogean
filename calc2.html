<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Character Planner Skeleton</title>
    <style>
        @font-face {
            font-family: 'bedstead';
            src: url('bedstead-extracondensed.otf') format('truetype');
        }
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            color: #fff;
        }
        body, .stat-container, .stat-container > div, .levelnumber, .leveltitle {
            font-family: 'bedstead', Arial, sans-serif;
        }
        #planner-container {
            width: 100vw;
            height: 100vh;
            flex-direction: column;
        }
        .planner-upper {
            width: 1250px;
            height: 400px;
            display: flex;
            flex-direction: row;
            border-bottom: 0px solid #000;
        }
        .planner-lower {
            width: 100%;
            height: 600px;
            border-top: 0px solid #000;
            align-items: stretch;
            justify-content: stretch;
        }
        /* Upper columns */
        .upper-col1 {
            width: 340px;
            border-right: 0px solid #000;
        }
        .upper-col1-segment {
            width: 100%;
            border-bottom: 0px solid #000;
            align-items: center;
            justify-content: center;
            font-size: 1em;
        }
        .class-choice {
            height: 80px;
        }
        .level-choice { 
            height: 100px; 
            width: 80px;
        }
        .stat-counter { 
            height: 100px; 
            width: 300px;
            display: flex;
        }
        .trait-counter { 
            height: 400px; 
            border-bottom: none; 
            width: 100px;
        }
        .points-row{
            width: 400px;
            display: flex;
        }
        .points-box{
            width: 70px;
            text-align: center;
            border: 2px solid #303030;
            background: rgba(0, 0, 0, 0.24);
            margin-left: 27px;
        }
        .upper-dynamic-cell {
            width: 910px;
            height: 100%;
            border-left: 0px solid #000;
            display: flex;
        }
        .upper-col2 {
            width: 400px;
            height: 100%;
            display: flex;
            flex-direction: column;
            border-right: 0px solid #000;
        }
        .upper-col2-stat-segment {
            display: flex;
            width: 200px;
        }

        .upper-col2-row1 {
            width: 400px;
            height: 276px;
            display: flex;
            border-bottom: 0px solid #000;
        }

        .upper-col2-row1-equip {
            width: 230px;
            height: 100%;
            border-right: 0px solid #000;
            display: flex;
            align-items: center;
            justify-content: left;
        }
        .upper-col2-row1-desc {
            width: 170px;
            height: 250px;
            padding-top: 10px;
            align-items: center;
            justify-content: center;
            text-align: center;
            border: 2px solid #303030;
            background: rgba(0, 0, 0, 0.24);
        }
        .upper-col2-row2 {
            width: 100%;
            height: 29%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .upper-col3 {
            width: 350px;
            height: 360px;
            display: block;
            align-items: center;
            justify-content: center;
            border: 2px solid #303030;
            background: rgba(0, 0, 0, 0.24);
            margin: 20px;
            overflow: scroll;
        }
        /* Lower segment */
        .stats-table-container {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: left;
            border: 0px solid #000;
        }
        .class-choice-row {
            display: flex;
            align-items: center;
            border: 1px solid #aaa;
            margin: 2px 0;
            padding: 4px;
            cursor: pointer;
            background: #222;
            color: #fff;
            transition: background 0.2s;
        }
        .class-choice-row.selected {
            background: #eaff8c;
            color: #222;
            border: 2px solid #eaff8c;
        }
        .class-choice-row img {
            width: 32px;
            height: 32px;
            margin-right: 10px;
        }
        .level-choice-inner {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .leveltitle {
            margin-bottom: 5px;
            color: #fff;
        }
        .levelnumber {
            width: 80px;
            height: 40px;
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            border: 1px solid #aaa;
            border-radius: 8px;
            background-color: #222;
            color: #eaff8c;
        }
        .stat-table-outer {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        .stat-container {
            display: grid;
            grid-template-columns: 120px 50px 50px 20px 20px 35px 60px 50px 140px 100px 210px 100px 100px;
            gap: 0px;
            width: 1140px;
            height: 17px;
            margin-bottom: 0px;
            border-bottom: 1px solid #333;
            margin-top: 2px;
            font-size: 0.9em;
        }
        .stat-container:hover{
            background-color: rgb(46, 37, 0);
        }
        .stat-container.wide:hover{
            background-color: transparent;
        }
        .stat-container.wide {
            height: 40px;
        }
        .stat-container > div {
            padding: 1px;
            border: 0px solid black;
            text-align: center;
        }
        .item-grid {
            display: grid;
            grid-template-columns: repeat(3, 48px);
            grid-template-rows: repeat(4, 48px);
            gap: 5px;
            margin-left: 0px;
        }
        .item-slot {
            width: 48px;
            height: 48px;
            margin-left: 30px;
            border: 2px solid rgb(54, 54, 54);
            border-radius: 4px;
            background-color: rgb(17, 17, 17);
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .item-slot:hover{
            background-color: rgb(46, 37, 0);
        }
        .selected-equip-slot {
            outline: 0px solid #eaff8c;
        }
        .selection-grid {
            display: grid;
            grid-template-columns: repeat(6, 48px);
            gap: 6px;
            margin: 10px;
        }
        .selection-item {
            width: 48px;
            height: 48px;
            border: 2px solid rgb(54,54,54);
            border-radius: 4px;
            background-color: rgb(17, 17, 17);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .selection-item:hover {
            background-color: rgb(46, 37, 0);
        }
        .selection-item img {
            width: 40px;
            height: 40px;
        }
        .class-choice-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            width: 100%;
            height: 100%;
            align-items: center;
            justify-items: center;
        }
        .class-choice-cell {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .class-choice-cell:hover {
            transform: scale(1.1);
        }
        .class-choice-cell img {
            width: 64px;
            height: 64px;
            margin-bottom: 5px;
        }
        .class-choice-img{
            border: 3px solid #000000;
            filter: grayscale(100%);
            box-shadow: 0 0 12px 3px #000000, 0 0 2px 1px rgb(0, 0, 0);
        }
        .class-choice-img.selected {
            border: 3px solid #fff;
            box-shadow: 0 0 12px 3px #fff, 0 0 2px 1px #ffe;
            filter: grayscale(0%);
            /*add transition:*/;
            transition: filter 0.3s, box-shadow 0.3s;
        }
        /* --- TRAIT TREE STYLES (ported from calc.html) --- */
        .traits-panel {
            position: relative;
            width: 100%;
            height: 100%;
            margin-left: 0;
            background-color: rgba(36, 0, 0, 0);
            padding: 0px;
            border: 0px solid rgb(54, 54, 54);
            border-radius: 4px;
            color: rgb(239, 255, 148);
            display: flex;
            flex-wrap: wrap;
            overflow: auto;
        }
        .connector {
            position: absolute;
            z-index: 0;
            pointer-events: none;
            stroke: rgb(255, 255, 255);
            stroke-width: 2;
        }
        .trait {
            width: 24px !important;
            height: 30px !important;
            min-width: 24px !important;
            min-height: 28px !important;
            max-width: 24px !important;
            max-height: 28px !important;
            align-items: center;
            justify-content: center;
            font-size: 0.4em;
            font-weight: bold;
            background: transparent;
            color: #eaff8c;
            border: 1px solid transparent;;
            border-radius: 0px;
            user-select: none;
            overflow: hidden;
            padding: 0;
        }
        div.trait.active {
            background-color: rgb(57, 117, 0);
            transition: 0.5s;
        }
        .trait-title {
            font-weight: normal;
            margin-bottom: 0px;
            font-size: 0.5em;
            line-height: 1em;
            text-align: center;
            padding-right: 8px;
            padding-left: 8px;
            color: #d4b503;
        }
        .trait-description {
            margin-bottom: 2px;
            font-size: 0.4em;
            text-align: center;
            line-height: 0.8em;
            display: flex;
            justify-content: center;
            align-items: top;
            padding: 0;
            padding-top: 5px;
            opacity: 0.9;
            color: #dace8d;
        }
        .trait-stages {
            display: flex;
            justify-content: center;
            align-items: center;
            vertical-align: bottom;
            padding-top: 3px;
            font-size: 0.5em;
        }
        .trait-stages button {
            margin-right: 2px;
            margin-left: 2px;
            border-radius: 0;
            width: 65px;
            height: 15px;
            background-color: transparent;
            border: 0px solid transparent;
            font-family: 'bedstead', Arial, sans-serif;
            font-size: 0.9em;
            margin-bottom: 5px;
            line-height: 0.55em;
            color:rgb(0, 0, 0);
            font-weight: 50;
            text-shadow: 2px 2px 2px #0000008f;
        }
        .trait-stages button.active {
            color: rgb(234, 255, 47);
        }
        .trait-stages button.active.first-stage {
            color: rgb(90, 92, 67);
            display: none;
        }
        .trait-stages button.first-stage{
            display: none;
        }
        .trait.requirement-error {
            border: 1px solid #ff3333 !important;
        }
        /* --- ADDITIONAL STYLES FOR TINY STAGES BAR --- */
        .trait img{
            padding: 0;
            margin: 0;
        }
        .tiny-stages {
            width: 100%;
            height: 4px;
            display: flex;
            flex-direction: row;
            background: #444444;
            margin-top: 0px;
            padding: 0;
            border: 1px solid #000;;
        }
        .tiny-stages div {
            margin-right: 1px;
        }
        /*-- description of trait -- */
        
        .active-stage-desc {
            background: transparent;
            display: inline-flex;
            text-align: center;
            color: #eaff8c;
            display: inline-block;
            min-width: 20px;
            text-shadow: 2px 2px 2px #0000008f;
        }
        .inactive-stage-desc {
            background: transparent;
            display: inline-flex;
            text-align: center;
            color: #666666;
            display: inline-block;
            min-width: 20px;
            text-shadow: 2px 2px 2px #0000008f;
        }
        /*Rarity for images*/
        img.uncommon {
            filter: drop-shadow(0px 0px 5px #23ff2e);
        }
        img.rare {
            filter: drop-shadow(0px 0px 5px #00ccff);
        }
        img.epic {
            filter: drop-shadow(0px 0px 5px #f712eb)
        }
        img.legendary {
            filter: drop-shadow(0px 0px 5px #ffee01)
        }
        /* item size fix*/
        
        .item-slot img.size-32, .selection-item img.size-32 {
            width: 48px;
            height: 48px;
        }
        .item-slot img.size-16, .selection-item img.size-16 {
            width: 24px;
            height: 24px;
        }
        button {
            background-color: rgb(61, 204, 69);
            color: black;
            transition: 0.6s;
        }
        button.stats{
            height: 12px;
            width: 12x;
            background: transparent;
            border: none;
        }
        button.stats img{
            width: 13px;
            height: 13px;
            border: 1px solid #fff;
            border-radius: 3px;
            margin-top: -2px;
        }
        /*change image on hover*/
        img.plus{
            content: url("Icons/plus.png");
        }
        img.plus:hover{
            content: url("Icons/plus_hover.png");
        }
        img.minus{
            content: url("Icons/minus.png");
        }
        img.minus:hover{
            content: url("Icons/minus_hover.png");
        }
        /* equip size invalid */
        
        .item-slot.invalid {
            border-color: red;
        }
    </style>
</head>
<body>
<div id="planner-container">
    <div class="planner-upper">
        <div class="upper-col1">
            <div class="upper-col1-segment class-choice" style="align-items:center;justify-content:center;">
                <div class="class-choice-row-images" style="display:flex;padding-top: 5px; gap:10px;width:100%;justify-content:center;align-items:center;">
                    <img src="squire.png" alt="Squire" class="class-choice-img" data-class="Squire" style="width:48px;height:72px;cursor:pointer;">
                    <img src="knight.png" alt="Knight" class="class-choice-img" data-class="Knight" style="width:48px;height:72px;cursor:pointer;">
                    <img src="rogue.png" alt="Rogue" class="class-choice-img" data-class="Rogue" style="width:48px;height:72px;cursor:pointer;">
                    <img src="mage.png" alt="Mage" class="class-choice-img" data-class="Mage" style="width:48px;height:72px;cursor:pointer;">
                </div>
            </div>

                        <div class="upper-col1-segment traits-panel-col" style="align-items:center;justify-content:center;padding:0;">
                            <div id="traits-panel-mini" style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;"></div>
                        </div>
        </div>
        <div class="upper-dynamic-cell">
            <div id="planner-ui" style="width: 100%; height: 100%; display: flex; flex-direction: row;">
                <div class="upper-col2">


                    <div class="points-row">
                        <div class="upper-col2-stat-segment level-choice" style="display: flex; align-items:center;justify-content:center;">
                            <span style="color:#fff;margin-right:8px;">Level:</span>
                            <input class="levelnumber" type="number" id="level-input" min="1" max="100" value="1" style="width:60px;height:32px;font-size:1em;">
                        </div>
                        <div class="upper-col2-stat-segment stat-counter" style="align-items:center;justify-content:center;">
                            <span style="color:#fff;">Stat Points <span id="available-points">0</span>/<span id="total-points">0</span></span>
                        </div>
                    </div>


                    <div class="upper-col2-row1">
                        <div class="upper-col2-row1-equip">
                            <div class="item-grid">
                                <div class="item-slot" data-slot="neck"></div>
                                <div class="item-slot" data-slot="head"></div>
                                <div class="item-slot" data-slot="bagslot"></div>
                                <div class="item-slot" data-slot="hand"></div>
                                <div class="item-slot" data-slot="chest"></div>
                                <div class="item-slot" data-slot="hand"></div>
                                <div class="item-slot" data-slot="ring"></div>
                                <div class="item-slot" data-slot="legs"></div>
                                <div class="item-slot" data-slot="ammoslot"></div>
                                <div class="item-slot-x" data-slot="NONE"></div>
                                <div class="item-slot" data-slot="boots"></div>
                            </div>
                        </div>
                        <div class="upper-col2-row1-desc"></div>
                    </div>
                </div>
                <div class="upper-col3"></div>
            </div>
            <div id="trait-tree-ui" style="width: 100%; height: 100%; display: none; align-items: center; justify-content: center; font-size: 2em;">
                Trait tree
            </div>
        </div>
    </div>
    <div class="planner-lower">
        <div class="stats-table-container" id="stats-table-container">
            <!-- Stats table will be generated here by JS -->
        </div>
    </div>
</div>
<script src="itemdata.js"></script>
<script>
        // --- Class selection logic ---
        const classRows = [
            { name: "Squire", icon: "squire.png" },
            { name: "Knight", icon: "knight.png" },
            { name: "Rogue", icon: "rogue.png" },
            { name: "Mage", icon: "mage.png" }
        ];
        let selectedClass = null;
        let selectedLevel = 1;
        window.addEventListener('DOMContentLoaded', function() {
            // Make class rows selectable
            document.querySelectorAll('.class-choice-img').forEach(img => {
                img.addEventListener('click', function() {
                    document.querySelectorAll('.class-choice-img').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedClass = this.getAttribute('data-class');
                    updateDebug();
                });
            });
            // Level input
            const levelInput = document.getElementById('level-input');
            levelInput.addEventListener('input', function() {
                let val = parseInt(this.value) || 1;
                if(val < 1) val = 1;
                if(val > 100) val = 100;
                this.value = val;
                selectedLevel = val;
                updateDebug();
            });
            // Set default selection
            document.querySelector('.class-choice-img[data-class="Squire"]').click();
        });
        function updateDebug() {
            document.getElementById('stats-table-container').innerText =
                `Selected class: ${selectedClass || ''}\nLevel: ${selectedLevel}`;
        }
    </script>
<script>
// --- Item

// --- Traits database ---
const traits = [
        [0,0,"start","starts",[0],0,0,0,0,0,50],
[1,0,"Staff Mastery","Staves have a X% chance of shooting without cost",[0,15,25,40,60,90],0,0,0,0,-100,100],
[2,1,"Charge the Staff","Casting an Elemental spell using a staff will make your next attack deal extra (Magic Level / X) damage",["Off",5,4,2],0,0,0,0,-200,100],
[3,2,"Gallop’s Fall","Reduces the cooldown of Water spells by X%",[0,10,20,35],0,0,0,0,-300,200],
[4,3,"Sacred Stick","While holding a staff, gain 1 extra Area of Effect for Holy spells and 25% cooldown reduction for Holy spells",["Off", "active"],3,3,1,5,-400,300],
[5,2,"Franctic Conjury","Casting a Fire spell has a X% chance your next attack will cast Conjure Fire at target's location",[0, 15,20,30],0,0,0,0,-300,100],
[6,5,"Conflagrated Mind","While holding a staff gain 1 extra Area of Effect and 25% cooldown reudction for Fire spells",["Off","active"],5,3,1,5,-400,100],
[7,6,"Warlock","Gain 1 Area of Effect and doubles the cooldown of all spells",["Off","active"],0,0,0,0,-400,200],
[8,0,"Pondering It","Orbs give +X% Spellvamp",[0,1,3,6,10,15],0,0,0,0,-100,0],
[9,8,"Electric Nature","Reduces the cooldown of spells by X%",[0,7,10,15],0,0,0,0,-200,0],
[10,9,"Diamond Skin","Hitting and enemy with an Energy or Arrow spell gives you X magic shield, capping at 100",[0,20,30,50],0,0,0,0,-300,0],
[11,10,"Unstable Aegis","Taking Magic Shield damage has a 50% chance of casting Unstable Berserk around yourself",["Off","active"],10,3,8,5,-400,0],
[12,9,"Magic Touch","Heal spells are X% stronger",[0,10,15,25],0,0,0,0,-300,-100],
[13,12,"Apogea’s Ardor","While holding an Orb, Heal spells cost 50% less mana",["Off","active"],12,3,8,5,-400,-100],
[14,13,"Child’s channel","Healing others also heals you, reduces the cooldown of all spells by 50% and spells deal 75% less dammage",["Off","active"],0,0,0,0,-400,-200],
[15,0,"Blade training","Regular swords have X% extra damage",[0,1,4,8,13,20],0,0,0,0,-100,-100],
[16,15,"Hand Finesse","Gain 1 Attackspeed for each X Ability you have capping at 5",[0,15,13,10],0,0,0,0,-200,-100],
[17,16,"Fencing Classes","Blade spells are X% stronger",[0,5,9,15],0,0,0,0,-300,-200],
[18,17,"Blade Prowess","While holding one sword of size 6 and no shield, reduces the cooldown of Blade spells by 50%",["Off","active"],17,3,15,5,-300,-300],
[19,18,"Highlander","Blade spells cost 50% less mana, lose the ability to auto-attack. Additionally, converts every 2 Attackspeed into 1 Damage",["Off","active"],0,0,0,0,-400,-300],
[20,16,"Dual-wielding","Size 6 swords have an equipsize of 5, but deal X% less damage",[0,40,36,30],0,0,0,0,-200,-200],
[21,20,"To be Ninja","Attacking has a 25% chance of boosting your Movespeed by 10 for 4 seconds",["Off","active"],16,3,15,5,-200,-300],
[22,0,"Glove Passion","While wearing gloves, gain X Mana or Health Regen depending on the item you're holding",[0,1,2,3,6,10],0,0,0,0,0,-100],
[23,22,"True Grip","While wearing gloves, attacking regenerates X mana",[0,1,2,4],0,0,0,0,0,-200],
[24,23,"Unnatural Flow","Your attacks deal X extra True Damage",[0,4,7,12],0,0,0,0,-100,-200],
[25,24,"Battle Mage","Converts 50 Max Mana into 1 extra True Damage",["Off","active"],24,3,22,5,-100,-300],
[26,25,"One with Apogea","Mana damage is reduced in half. Mana damage is reduced in half, all spells cost 5 times more.",["Off","active"],0,0,0,0,0,-300],
[27,23,"Elvish Practice","Spells cost X% less mana",[0,7,10,15],0,0,0,0,100,-200],
[28,27,"Arcane Trickster","While using Gloves, casting a Time or Mystic spell has a 50% chance of blocking all physical damage for 4 seconds",["Off","active"],27,3,22,5,100,-300],
[29,0,"Going Big","Large weapons have X% extra damage",[0,1,4,8,14,20],0,0,0,0,100,-100],
[30,29,"Steady Bloodflow","Casting a spell using health regenerates X mana",[0,4,7,12],0,0,0,0,200,-200],
[31,30,"Berserker","Being below 66% Health gives you X extra Damage",[0,5,8,13],0,0,0,0,200,-300],
[32,31,"Overwhelming Force","When using Large weapon, attacking has a 35% chance of casting an area of effect spell around the target",["Off","active"],31,3,29,5,300,-300],
[33,30,"Wrecking It","Casting a Blade or Physical spell will make your next attack deal X extra True Damage",[0,4,8,14],0,0,0,0,300,-200],
[34,33,"Magic Blade","Removes negative effects from Large Weapnsand gain 10% Manaleech",["Off","active"],33,3,29,5,400,-200],
[35,34,"Unfathomable Rage","Converts every 2 damage taken into 1 mana, doubles the cost of all spells",["Off","active"],0,0,0,0,400,-300],
[36,0,"Stabbing Preference","Daggers provide X% Lifeleech",[0,1,3,6,10,15],0,0,0,0,100,0],
[37,36,"Through Puncture","Physical attacks ignore X% of the target’s armor",[0,8,20,35],0,0,0,0,200,0],
[38,37,"Jagged Rhythm","Attacking using a dagger has a X% chance of dealing extra (Ability/4) True Damage",[0,15,25,50],0,0,0,0,200,-100],
[39,38,"Luck Foreseen","Converts every 6 Ability into 1% chance of attacking twice",["Off","active"],38,3,36,5,300,-100],
[40,39,"Dark Blade","Doubles all True Damage you deal, you also receive the True Damage dealt",["Off","active"],0,0,0,0,400,-100],
[41,37,"Gaff Hack","Casting a Mystic or Time spell has a X% chance of boosting your Attackspeed by 7 for 4 seconds",[0,20,30,50],0,0,0,0,300,0],
[42,41,"Double Danger","Using two daggers doubles your item damage",["Off","active"],41,3,36,5,400,0],
[43,0,"Bow Guidance","Bows have X extra Attackspeed",[0,1,2,3,4,6],0,0,0,0,100,100],
[44,43,"Good Technique","Gain X extra Range",[0,1,2,4],0,0,0,0,200,100],
[45,44,"Artisenal Arsenal","Non-magic arrow get +X Damage and break less often",[0,2,4,7],0,0,0,0,300,100],
[46,45,"Explosive Ammo","Arrows have a 25% chance of exploding, dealing area damage that briefly slows",["Off","active"],45,3,43,5,400,100],
[47,44,"Shineshooter","Reduces the cooldown of Arrow spells by X%",[0,10,20,35],0,0,0,0,300,200],
[48,47,"Bullseye","Increases the damage of Arrow and Blade spells on enemies you currently have targeted",["Off","active"],47,3,43,5,400,200],
[49,48,"Tunnelvision","Gain 10 Attackspeed, but you can no longer move while targeting an enemy.",["Off","active"],0,0,0,0,400,300],
[50,0,"Cozy and Useful","Light Armor has X extra mana",[0,1,3,6,10,15],0,0,0,0,-100,200],
[51,50,"Lightfoot","Converts X Free Capacity into 1 Movespeed capping at 3",[0,35,25,10],0,0,0,0,-200,200],
[52,51,"Dress Wizardly","Light Armor that weighs less than X oz gives you +1 Magic",[0,10,20,35],0,0,0,0,-300,300],
[53,52,"Clothes of the Damned","Removes negative effects from Light Armor and gain 5% Magic for each equipped Light Armor.",["Off","active"],52,3,50,5,-300,400],
[54,53,"Darkness Embrace","Death spells are 10 times cheaper. Heal, Light and Holy spells are 10 times more expensive.",["Off","active"],0,0,0,0,-400,400],
[55,51,"Breeze in your hair","Not wearing a helmet gives you +X Movespeed",[0,1,2,3],0,0,0,0,-200,300],
[56,55,"Battle Boots","Gives 1% chance of dealing 1.5x damage for every 1 Movespeed",["Off","active"],55,3,50,5,-200,400],
[57,0,"Block Efficiacy","Shields have X% extra defense",[0,1,4,8,13,20],0,0,0,0,0,200],
[58,57,"Rooted Guard","Blocking an attack regenerates X health",[0,1,2,5],0,0,0,0,0,300],
[59,58,"Hex Parry","Successfully blocking an attack will empower your next Arrow or Blade spell by X%",[0,15,35,50],0,0,0,0,100,300],
[60,59,"Bulwark Leap","While holding a shield, casting a Time or Physical spell will double your Magic Shield, capping at 200",["Off","active"],59,3,57,5,100,400],
[61,58,"Royal Shield","Reduces the cooldown of Defense spells by X%",[0,10,20,35],0,0,0,0,-100,300],
[62,61,"Deflect","Blocking with a Magic Shield reflects 15% of the damage taken as True Damage",["Off","active"],61,3,57,5,-100,400],
[63,62,"Monster Candy","Taunt lasts 100% longer, Conjure and Defense spells are 50% cheaper. Lose 99 Damage.",["Off","active"],0,0,0,0,0,400],
[64,0,"Well Protected","Heavy Armor has X extra health",[0,1,3,6,10,15],0,0,0,0,100,200],
[65,64,"Heavy Metal","Heavy Armor that weighs more than X oz. has 1 Ability extra",[0,100,75,35],0,0,0,0,200,200],
[66,65,"Magic Steel","Casting a Time or Heal spell gives you a Magic Shield equal to X% of your Armor, capping at 100",[0,50,75,100],0,0,0,0,200,300],
[67,66,"Blessed Plate","Heavy Armor has 1 Magic and 25 Mana extra",["Off","active"],66,3,64,5,200,400],
[68,65,"Carry Your Might","Gain 1 Armor for every 100 Max Capacity, capping at X",[0,2,4,8],0,0,0,0,300,300],
[69,68,"Juggernaut","Removes negative effects from Heavy Armor. Gain 5% Ability for each equipped Heavy Armor.",["Off","active"],68,3,64,5,300,400],
[70,69,"Endowed in Steel","Using both your hands gives you +10% lifesteal, +23 Damage, +13 Ability and +7 Attack Speed",["Off","monk"],0,0,0,0,400,400],
        ];
// --- Stat Table Logic ---
const statList = [
    "Health", "Mana", "Magic", "Damage", "Min Damage", "Max Damage", "Average Damage Per Hit", "Bow Damage", "True Damage","Min True Damage", "Max True Damage", "Average True Damage Per Hit", "DPS", "Movespeed", "Ability", "Attack Speed", "HP Regen", "MP Regen", "Range", "Armor", "Defense", "Capacity"
];
let addedPoints = {};
statList.forEach(stat => addedPoints[stat] = 0);
let availablePoints = 0;

const allocatableStats = [
    "Health", "Mana", "Magic", "Ability", "HP Regen", "MP Regen", "Capacity"
];

// Class multipliers for each stat and class
const classMultipliers = {
    Squire:    { Health: 1.00, Mana: 1.00, Magic: 1.00, Damage: 1.00, "Min Damage": 1.00, "Max Damage": 1.00, "Average Damage Per Hit": 1.00, "Bow Damage": 1.00, "True Damage": 1.00, "Min True Damage": 1.00, "Max True Damage": 1.00, "Average True Damage Per Hit": 1.00, DPS: 1.00, Movespeed: 1.00, Ability: 1.00, "Attack Speed": 1.00, "HP Regen": 1.00, "MP Regen": 1.00, Range: 1.00, Armor: 1.00, Defense: 1.00, "Capacity Used": 1.00, "Capacity Free": 1.00, Capacity: 1.00 },
    Knight:    { Health: 2.00, Mana: 0.50, Magic: 0.50, Damage: 1.00, "Min Damage": 1.00, "Max Damage": 1.00, "Average Damage Per Hit": 1.00, "Bow Damage": 1.00, "True Damage": 1.00, "Min True Damage": 1.00, "Max True Damage": 1.00, "Average True Damage Per Hit": 1.00, DPS: 1.00, Movespeed: 1.00, Ability: 1.25, "Attack Speed": 1.00, "HP Regen": 1.25, "MP Regen": 0.50, Range: 1.00, Armor: 1.50, Defense: 1.50, "Capacity Used": 1, "Capacity Free": 1, Capacity: 1.50 },
    Rogue:     { Health: 1.00, Mana: 1.25, Magic: 1.50, Damage: 1.00, "Min Damage": 1.00, "Max Damage": 1.00, "Average Damage Per Hit": 1.00, "Bow Damage": 1.00, "True Damage": 1.00, "Min True Damage": 1.00, "Max True Damage": 1.00, "Average True Damage Per Hit": 1.00, DPS: 1.00, Movespeed: 1.00, Ability: 1.50, "Attack Speed": 1.25, "HP Regen": 1.00, "MP Regen": 1.00, Range: 1.00, Armor: 1.00, Defense: 1.00, "Capacity Used": 1.00, "Capacity Free": 1.00, Capacity: 1.00 },
    Mage:      { Health: 0.75, Mana: 2.00, Magic: 2.00, Damage: 1.00, "Min Damage": 1.00, "Max Damage": 1.00, "Average Damage Per Hit": 1.00, "Bow Damage": 1.00, "True Damage": 1.00, "Min True Damage": 1.00, "Max True Damage": 1.00, "Average True Damage Per Hit": 1.00, DPS: 1.00, Movespeed: 1.00, Ability: 0.75, "Attack Speed": 1.00, "HP Regen": 0.75, "MP Regen": 2.00, Range: 1.00, Armor: 0.75, Defense: 0.75, "Capacity Used": 1, "Capacity Free": 1, Capacity: 0.75 }
};
// Point value for each allocatable stat
const pointValues = {
    Health: 5,
    Mana: 5,
    Magic: 1,
    Ability: 1,
    "HP Regen": 1,
    "MP Regen": 1,
    Capacity: 25
};
// Global stat data structure
const statData = {
    Health:      { base: 150, statBonus: 0, itemBonus: 0, traitBonus: 0, final: 150 },
    Mana:        { base: 15,  statBonus: 0, itemBonus: 0, traitBonus: 0, final: 15 },
    Magic:       { base: 0,   statBonus: 0, itemBonus: 0, traitBonus: 0, final: 0 },
    Damage:      { base: 0,   statBonus: 0, itemBonus: 0, traitBonus: 0, final: 0 },
    "Min Damage": { base: 0,   statBonus: 0, itemBonus: 0, traitBonus: 0, final: 0 },
    "Max Damage": { base: 0,   statBonus: 0, itemBonus: 0, traitBonus: 0, final: 0 },
    "Average Damage Per Hit": { base: 0,   statBonus: 0, itemBonus: 0, traitBonus: 0, final: 0 },
    "Bow Damage": { base: 0,   statBonus: 0, itemBonus: 0, traitBonus: 0, final: 0 },
    "True Damage":      { base: 0,   statBonus: 0, itemBonus: 0, traitBonus: 0, final: 0 },
    "Min True Damage": { base: 0,   statBonus: 0, itemBonus: 0, traitBonus: 0, final: 0 },
    "Max True Damage": { base: 0,   statBonus: 0, itemBonus: 0, traitBonus: 0, final: 0 },
    "Average True Damage Per Hit": { base: 0,   statBonus: 0, itemBonus: 0, traitBonus: 0, final: 0 },
    DPS:         { base: 0,   statBonus: 0, itemBonus: 0, traitBonus: 0, final: 0 },
    Movespeed:   { base: 35,  statBonus: 0, itemBonus: 0, traitBonus: 0, final: 35 },
    Ability:     { base: 0,   statBonus: 0, itemBonus: 0, traitBonus: 0, final: 0 },
    "Attack Speed": { base: 10,  statBonus: 0, itemBonus: 0, traitBonus: 0, final: 10 },
    "HP Regen":     { base: 1,   statBonus: 0, itemBonus: 0, traitBonus: 0, final: 1 },
    "MP Regen":     { base: 1,   statBonus: 0, itemBonus: 0, traitBonus: 0, final: 1 },
    Range:       { base: 15,  statBonus: 0, itemBonus: 0, traitBonus: 0, final: 15 },
    Armor:       { base: 0,   statBonus: 0, itemBonus: 0, traitBonus: 0, final: 0 },
    Defense:     { base: 0,   statBonus: 0, itemBonus: 0, traitBonus: 0, final: 0 },
    "Capacity Used": { base: 0, statBonus: 0, itemBonus: 0, traitBonus: 0, final: 0 },
    "Capacity Free": { base: 0, statBonus: 0, itemBonus: 0, traitBonus: 0, final: 0 },
    Capacity:    { base: 225, statBonus: 0, itemBonus: 0, traitBonus: 0, final: 225 }
};

// Define baseValues for each stat (used in updateStatTable)
const baseValues = {
    Health: 150,
    Mana: 15,
    Magic: 0,
    Damage: 0,
    "Min Damage": 0,
    "Max Damage": 0,
    "Average Damage Per Hit": 0,
    "Bow Damage": 0,
    "True Damage": 0,
    "Min True Damage": 0,
    "Max True Damage": 0,
    "Average True Damage Per Hit": 0,
    DPS: 0,
    Movespeed: 35,
    Ability: 0,
    "Attack Speed": 10,
    "HP Regen": 1,
    "MP Regen": 1,
    Range: 15,
    Armor: 0,
    Defense: 0,
    "Capacity Used": 0,
    "Capacity Free": 0,
    Capacity: 225
};
 function SetImageSize(img) {
                const image = new Image();
                image.src = img.src;
                image.onload = function() {
                    if (image.width === 32 && image.height === 32) {
                        img.classList.add('size-32');
                        img.classList.remove('size-16');
                    } else if (image.width === 16 && image.height === 16) {
                        img.classList.add('size-16');
                        img.classList.remove('size-32');
                    } else {
                        img.classList.remove('size-32', 'size-16');
                    }
                };
            }

function updateStatData() {
    // Update statBonus from allocated points
    statData.Health.statBonus = addedPoints["Health"] * 5;
    statData.Mana.statBonus = addedPoints["Mana"] * 5;
    statData.Magic.statBonus = addedPoints["Magic"] * 1;
    statData.Ability.statBonus = addedPoints["Ability"] * 1;
    statData["HP Regen"].statBonus = addedPoints["HP Regen"] * 1;
    statData["MP Regen"].statBonus = addedPoints["MP Regen"] * 1;
    // Other stats get 0 from stat allocation
    statData.Damage.statBonus = 0;
    statData["Min Damage"].statBonus = 0;
    statData["Max Damage"].statBonus = 0;
    statData["Average Damage Per Hit"].statBonus = 0;
    statData["Bow Damage"].statBonus = 0;
    statData["True Damage"].statBonus = 0;
    statData["Min True Damage"].statBonus = 0;
    statData["Max True Damage"].statBonus = 0;
    statData["Average True Damage Per Hit"].statBonus = 0;
    statData.DPS.statBonus = 0;
    statData.Movespeed.statBonus = 0;
    statData["Attack Speed"].statBonus = 0;
    statData.Range.statBonus = 0;
    statData.Armor.statBonus = 0;
    statData.Defense.statBonus = 0;
    statData["Capacity Used"].statBonus = 0;
    statData["Capacity Free"].statBonus = addedPoints["Capacity"] * 25;
    statData.Capacity.statBonus = addedPoints["Capacity"] * 25;
    // Item and trait bonuses can be set elsewhere
    // Calculate final values (with class multiplier)
    const currentClass = selectedClass || "Squire";
    for (let stat in statData) {
        const mult = classMultipliers[currentClass][stat] || 1;
        statData[stat].final = (
            statData[stat].base +
            statData[stat].statBonus +
            statData[stat].itemBonus +
            statData[stat].traitBonus
        ) * mult;
    }
}
// Example dependent stat calculation
function getBowDamage() {
    // Example: Bow Damage = Damage.final * 1.5 + Attack Speed.final * 0.5

    let value = statData["Damage"].final + (statData["Attack Speed"].final / 5) + (statData["Movespeed"].final / 5);
    console.log("Bow Damage:", value);
    return value;
}
function getDPS() {
    // Example: DPS = Damage.final / Attack Speed.final
    return statData["Attack Speed"].final !== 0 ? (statData.Damage.final / statData["Attack Speed"].final) : 0;
}
// In updateStatTable, call updateStatData() before rendering
function updateStatTable() {
    const level = selectedLevel;
    const totalStatPoints = (level - 1) * 3;
    let usedPoints = 0;
    statList.forEach(stat => usedPoints += addedPoints[stat]);
    availablePoints = totalStatPoints - usedPoints;
    // Stat and trait counter
    document.querySelector('.stat-counter').innerHTML =
        `<div class="points-box">
            Stat<br>Points:<br><span id='available-points'>${availablePoints}</span>/<span id='total-points'>${totalStatPoints}</span><br>
            </div>
            <div class="points-box">
            Trait<br>Points:<br><span id='available-trait-points'>${getRemainingTraitPoints()}</span>/<span id='total-trait-points'>${getAvailableTraitPoints(level)}</span>
        </div>`;
    // Build stat table (manual rows for each stat)
    let html = `<div class=\"stat-table-outer\">`;
    html += `<div class=\"stat-container wide\">
        <div>Stat</div>
        <div>Class<br>Multiplier</div>
        <div>Base</div>
        <div>-</div>
        <div>+</div>
        <div>Pts</div>
        <div style='min-width:50px;'>Stat<br>Calc</div>
        <div>Stat<br>Bonus</div>
        <div style='min-width:50px;'>Item Calculation</div>
        <div>Item Bonus</div>
        <div style='min-width:120px;'>Traits Calculation</div>
        <div>Traits Bonus</div>
        <div>Final<br>Value</div>
    </div>`;
    const currentClass = selectedClass || "Squire";
    // Health
    html += buildStatRow("Health", baseValues["Health"], currentClass);
    // Mana
    html += buildStatRow("Mana", baseValues["Mana"], currentClass);
    // Magic
    html += buildStatRow("Magic", baseValues["Magic"], currentClass);
    // Damage
    html += buildStatRow("Damage", baseValues["Damage"], currentClass);
    // Min Damage
    html += buildStatRow("Min Damage", 0, currentClass);
    // Max Damage
    html += buildStatRow("Max Damage", 0, currentClass);
    // Average Damage Per Hit
    html += buildStatRow("Average Damage Per Hit", 0, currentClass);
    // Bow Damage
    html += buildStatRow("Bow Damage", 0, currentClass);
    // True Damage
    html += buildStatRow("True Damage", 0, currentClass);
    // Min True Damage
    html += buildStatRow("Min True Damage", 0, currentClass);
    // Max True Damage
    html += buildStatRow("Max True Damage", 0, currentClass);
    // Average True Damage Per Hit
    html += buildStatRow("Average True Damage Per Hit", 0, currentClass);
    // DPS
    html += buildStatRow("DPS", 0, currentClass);
    // Movespeed
    html += buildStatRow("Movespeed", baseValues["Movespeed"], currentClass);
    // Ability
    html += buildStatRow("Ability", baseValues["Ability"], currentClass);
    // Attack Speed
    html += buildStatRow("Attack Speed", baseValues["Attack Speed"], currentClass);
    // HP Regen
    html += buildStatRow("HP Regen", baseValues["HP Regen"], currentClass);
    // MP Regen
    html += buildStatRow("MP Regen", baseValues["MP Regen"], currentClass);
    // Range
    html += buildStatRow("Range", baseValues["Range"], currentClass);
    // Armor
    html += buildStatRow("Armor", baseValues["Armor"], currentClass);
    // Defense
    html += buildStatRow("Defense", baseValues["Defense"], currentClass);
    // Capacity Used
    html += buildStatRow("Capacity Used", 0, currentClass);
    // Capacity Free
    html += buildStatRow("Capacity Free", statData["Capacity"].final, currentClass);
    // Capacity
    html += buildStatRow("Capacity", baseValues["Capacity"], currentClass);
    html += `</div>`;
    document.getElementById('stats-table-container').innerHTML = html;
}
function buildStatRow(stat, baseValue, currentClass) {
    let added = addedPoints[stat];
    let canAllocate = false;
    let classMult = 1;
    let multiplier = '';
    let pointVal = 0;
    let statCalc = '';
    let statBonus = 0;
    let itemCalc = '';
    let itemBonus = 0;
    canAllocate = allocatableStats.includes(stat);
    classMult = classMultipliers[currentClass][stat] || 1;
    multiplier = (classMult * 100).toFixed(0)+"%";
    pointVal = pointValues[stat] || 0;
    //statCalc = `${baseValue}`;
    if (canAllocate && added > 0) statCalc += `(${added} x ${pointVal}) x ${multiplier}`;
    
    if (canAllocate) statBonus += added * pointVal;
    statBonus = (statBonus * classMult).toFixed(2);
    //get this stat's item bonus from all class item-slot elements
    const itemSlots = document.querySelectorAll('.item-slot');
    itemSlots.forEach(slot => {
        const img = slot.querySelector('img');
        if (img && img.alt) {
            //console.log(`Processing item: ${img.alt}`);
            const itemName = img.alt.split(';')[0];
            const itemRarity = img.alt.split(';')[1] || '';
            //console.log(`Item name: ${itemName}, Rarity: ${itemRarity}`);
            //find using item's name and rarity [1]
            const item = items.find(i => i[0] === itemName && i[i.length-1] === itemRarity);
            if (item) {
                //name	 slot	 type	 weight	 range	 DMG	 hp	 mana	ability	 magic	 arm	 def	 moveS	 atkSpd	 ??	 eqSize	HP reg	MP reg	 description 	rarity

                switch(stat){
                    case "Health":
                        itemBonus += item[6] || 0;
                        if(item[6] != null){
                            if(itemCalc != ''){
                                itemCalc += ` + `;
                            }
                            itemCalc += `${item[6] || 0}`;
                        }
                        break;
                    case "Mana":
                        itemBonus += item[7] || 0;
                        if(item[7] != null){
                            if(itemCalc != ''){
                                itemCalc += ` + `;
                            }
                            itemCalc += `${item[7] || 0}`;
                        }
                        break;
                    case "Magic":
                        itemBonus += item[9] || 0;
                        if(item[9] != null){
                            if(itemCalc != ''){
                                itemCalc += ` + `;
                            }
                            itemCalc += `${item[9] || 0}`;
                        }
                        break;
                    case "Damage":
                        itemBonus += item[5] || 0;
                        if(item[5] != null){
                            if(itemCalc != ''){
                                itemCalc += ` + `;
                            }
                            itemCalc += `${item[5] || 0}`;
                        }
                        break;
                    case "Movespeed":
                        itemBonus += item[12] || 0;
                        if(item[12] != null){
                            if(itemCalc != ''){
                                itemCalc += ` + `;
                            }
                            itemCalc += `${item[12] || 0}`;
                        }
                        break;
                    case "Ability":
                        itemBonus += item[8] || 0;
                        if(item[8] != null){
                            if(itemCalc != ''){
                                itemCalc += ` + `;
                            }
                            itemCalc += `${item[8] || 0}`;
                        }
                        break;
                    case "Attack Speed":
                        itemBonus += item[13] || 0;
                        if(item[13] != null){
                            if(itemCalc != ''){
                                itemCalc += ` + `;
                            }
                            itemCalc += `${item[13] || 0}`;
                        }
                        break;
                    case "HP Regen":
                        itemBonus += item[16] || 0;
                        if(item[16] != null){
                            if(itemCalc != ''){
                                itemCalc += ` + `;
                            }
                            itemCalc += `${item[16] || 0}`;
                        }
                        break;
                    case "MP Regen":
                        itemBonus += item[17] || 0;
                        if(item[17] != null){
                            if(itemCalc != ''){
                                itemCalc += ` + `;
                            }
                            itemCalc += `${item[17] || 0}`;
                        }
                        break;
                    case "Range":
                        if(itemBonus < item[4]){
                            itemBonus = item[4];
                            if(item[4] != null){
                                itemCalc = `${item[4] || 0}`;
                            }
                        }
                        break;
                    case "Armor":
                        itemBonus += item[10] || 0;
                        if(item[10] != null){
                            if(itemCalc != ''){
                                itemCalc += ` + `;
                            }
                            itemCalc += `${item[10] || 0}`;
                        }
                        break;
                    case "Defense":
                        itemBonus += item[11] || 0;
                        if(item[11] != null){
                            if(itemCalc != ''){
                                itemCalc += ` + `;
                            }
                            itemCalc += `${item[11] || 0}`;
                        }
                        break;
                    case "Capacity Used":
                        //add item[3] (weight) to Capacity Used
                        itemBonus += item[3]/10 || 0;
                        if(item[3] != null){
                            if(itemCalc != ''){
                                itemCalc += ` + `;
                            }
                            itemCalc += `${(item[3]/10) || 0}`;
                        }
                        break;
                    case "Capacity Free":
                        itemBonus -= (item[3]/10) || 0;
                        if(item[3] != null){
                            if(itemCalc != ''){
                                itemCalc += ` - `;
                            }
                            itemCalc += `${(item[3]/10) || 0}`;
                        }
                    case "Capacity":
                        itemBonus += item[15] || 0;
                        if(item[15] != null){
                            if(itemCalc != ''){
                                itemCalc += ` + `;
                            }
                            itemCalc += `${item[15] || 0}`;
                        }
                        break;
                }
                
                //console.log(`Found item: ${item[0]} with rarity ${itemRarity}`);
                const itemStat = item[stat.toLowerCase().replace(' ', '')];
                if (itemStat && !isNaN(itemStat)) {
                    itemBonus += itemStat * classMult;
                    itemCalc += ` + ${itemStat}`;
                }
            }
        }
    });

    if (itemCalc != ''){
        itemCalc =  `[(`+itemCalc+`) x ${multiplier}]`;
    }

    //MAGIC AND ABILITY ON ITEMS - exception
    if(stat === "Magic" || stat === "Ability"){
        itemBonus = itemBonus.toFixed(2);
    }
    else{
        itemBonus = (itemBonus * classMult).toFixed(2);
    }
    if(stat === "Range"){
        console.log("!!!!!!!!!!!!!aaa RANGE ITEM BONUS: " + statData["Range"].itemBonus);
        console.log("!!!!!!!!!!!!!bbb RANGE ITEM BONUS: " + itemBonus);
    }

    //---------------------------------------------------
    //---------------------------------------------------
    //---------------------------------------------------
    //----- Traits calculation START-----
    //---------------------------------------------------
    //---------------------------------------------------
    //---------------------------------------------------

    //check the stage of Trait ID 15, Blade Training
    traitBonus = 0;
    let traitCalc = '';
    //console.log("TEST: "+selectedTraits[15]);
    //15 - Blade Training
    if (parseInt(selectedTraits[15]) > 0) {
        if(stat === "Damage"){
            let traitStage = parseInt(selectedTraits[15]);
            console.log("Blade Training is selected with level: " + selectedTraits[15]);
            //check if item in left hand type == sword
            let damageOfItem = 0;
            //data-slot = 'hand'
            const itemInHand = document.querySelectorAll('.item-slot[data-slot="hand"] img');
            if (itemInHand[0]) {
                let item;
                if(itemInHand[0].alt) {
                    const [name, rarity] = itemInHand[0].alt.split(';');
                    item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                    //if(item) console.log("Found item in left hand: " + item[0]+ " with rarity: " + rarity+ " and damage: " + item[5]);
                }                
                if(!item) return; //if not found item
                damageOfItem = item[5] || 0;
                typeOfItem = item[2] || '';
                if(typeOfItem == 'sword'){
                    traitBonus += Math.max(1,damageOfItem * (traitStage / 100));
                    if (traitCalc != '') {
                        traitCalc += ` + `;
                    }   
                    traitCalc += `Max(1, (${damageOfItem} x (${traitStage}%))`;
                }
            }
            if(itemInHand.length > 1){
                if(itemInHand[1]) {
                    let item;
                    if(itemInHand[1].alt) {
                        const [name, rarity] = itemInHand[1].alt.split(';');
                        item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                        //if(item) console.log("Found item in left hand: " + item[0]+ " with rarity: " + rarity+ " and damage: " + item[5]);
                    }                
                    if(!item) return; //if not found item
                    damageOfItem = item[5] || 0;
                    typeOfItem = item[2] || '';
                    if(typeOfItem == 'sword'){
                        traitBonus += Math.max(1,damageOfItem * (traitStage / 100));
                        if (traitCalc != '') {
                            traitCalc += ` + `;
                        }
                        traitCalc += `Max(1, (${damageOfItem} x (${traitStage}%))`;
                    }
                }
            }
        }
    }

    //16 - Hand Finesse - Gain 1 Attackspeed for each X Ability you have capping at 5
    if (parseInt(selectedTraits[16]) > 0) {
        console.log("Stat: " + stat);
        if(stat === "Attack Speed"){
            let traitStage = parseInt(selectedTraits[16]);
            console.log("Hand Finesse is selected with level: " + selectedTraits[16]);
            //get total Ability from stats and from items
            console.log(statData);
            let totalAbility = statData["Ability"].statBonus + statData["Ability"].itemBonus;
            console.log("Stat bonus: " + statData["Ability"].statBonus + " Item Bonus: " + statData["Ability"].itemBonus + " Total Ability: " + totalAbility);
            //divide Ability by traitStage
            let abilityToAdd = Math.ceil(totalAbility / traitStage);
            //cap at 5
            abilityToAdd = Math.min(abilityToAdd, 5);
            traitBonus += abilityToAdd;
            if (traitCalc != '') {
                traitCalc += ` + `;
            }
            traitCalc += `Min(floor(${totalAbility} / ${traitStage}), 5)`;
            //check if item in left hand type == sword
        }
    }

    // 19 - Highlander - Blade spells cost 50% less mana, lose the ability to auto-attack. Additionally, converts every 2 Attackspeed into 1 Damage
    if (selectedTraits[19] != "Off" && selectedTraits[19]) {
        if(stat === "Damage"){
            console.log("Highlander is selected with level: " + selectedTraits[19]);
            //get total Attack Speed from stats and from items. Include base Attack Speed
            let totalAttackSpeed = 10 + statData["Attack Speed"].statBonus + statData["Attack Speed"].itemBonus;
            //console.log("Stat bonus: " + statData["Attack Speed"].statBonus + " Item Bonus: " + statData["Attack Speed"].itemBonus + " Total Attack Speed: " + totalAttackSpeed);
            //divide Attack Speed by 2
            let attackSpeedToAdd = Math.floor(totalAttackSpeed / 2);
            traitBonus += attackSpeedToAdd;
            if (traitCalc != '') {
                traitCalc += ` + `;
            }
            traitCalc += `floor(${totalAttackSpeed} / 2)`; //TODO: Check if Highlander also converts base ASPD
        }
    }
    //20 - Dual-wielding - Size 6 swords have an equipsize of 5, but deal X% less damage
    if(selectedTraits[20] && selectedTraits[20] != 0) {
        if(stat === "Damage"){
            let traitStage = parseInt(selectedTraits[20]);
            console.log("Dual-wielding is selected with level: " + selectedTraits[20]);
            //Get damage for items in hand
            const itemsInHands = document.querySelectorAll('.item-slot[data-slot="hand"]');
            console.log("Item 1 in hands: ", itemsInHands[0]);
            console.log("Item 2 in hands: ", itemsInHands[1]);
            let damageOfItem1 = 0;
            let damageOfItem2 = 0;
            let damagePenalty = 0;
            if (itemsInHands[0] && itemsInHands[0].querySelector('img')) {
                const img1 = itemsInHands[0].querySelector('img');
                if (img1.alt) {
                    const [name, rarity] = img1.alt.split(';');
                    const item1 = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                    if (item1) {
                        damageOfItem1 = item1[5] || 0;
                        console.log("Found item in left hand: " + item1[0] + " with rarity: " + rarity + " and damage: " + item1[5]+" and equipsize: " + item1[15]);
                        if (item1[15] == 6){
                            damagePenalty += (damageOfItem1 * traitStage / 100);
                            traitCalc += ` - (${damageOfItem1} x (${traitStage}%))`;
                        }
                    }
                }
            }
            if (itemsInHands[1] && itemsInHands[1].querySelector('img')) {
                const img2 = itemsInHands[1].querySelector('img');
                if (img2.alt) {
                    const [name, rarity] = img2.alt.split(';');
                    const item2 = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                    if (item2) {
                        damageOfItem2 = item2[5] || 0;
                        console.log("Found item in right hand: " + item2[0] + " with rarity: " + rarity + " and damage: " + item2[5]+" and equipsize: " + item2[15]);
                        if (item2[15] == 6){
                            damagePenalty += (damageOfItem2 * traitStage / 100);
                            traitCalc += ` - (${damageOfItem2} x (${traitStage}%))`;
                        }
                    }
                }
            }
            //calculate damage penalty
            //apply damage penalty
            traitBonus -= damagePenalty;
        }
    }
    //22 - Glove Passion - While wearing gloves, gain X Mana or Health Regen depending on the item you're holding
    // type: staff or bow in hands, gain MP Regen. Otherwise, gain HP Regen
    if (selectedTraits[22] && selectedTraits[22] != 0) {
        if(stat === "HP Regen" || stat === "MP Regen"){
            let traitStage = parseInt(selectedTraits[22]);
            console.log("Glove Passion is selected with level: " + selectedTraits[22]);
            //get item types in hands
            const itemsInHands = document.querySelectorAll('.item-slot[data-slot="hand"] img');
            let itemType1 = '';
            let itemType2 = '';
            if (itemsInHands[0] && itemsInHands[0].alt) {
                const [name, rarity] = itemsInHands[0].alt.split(';');
                const item1 = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                if (item1) {
                    itemType1 = item1[2] || '';
                    console.log("Found item in left hand: " + item1[0] + " with rarity: " + rarity + " and type: " + itemType1);
                }
            }
            if (itemsInHands[1] && itemsInHands[1].alt) {
                const [name, rarity] = itemsInHands[1].alt.split(';');
                const item2 = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                if (item2) {
                    itemType2 = item2[2] || '';
                    console.log("Found item in right hand: " + item2[0] + " with rarity: " + rarity + " and type: " + itemType2);
                }
            }
            if(itemType1 === 'gloves' || itemType2 === 'gloves'){
                //if item in left hand is staff or bow, gain MP Regen
                if(itemType1 === 'staff' || itemType1 === 'bow' || itemType2 === 'staff' || itemType2 === 'bow'){
                    if(stat === "MP Regen"){
                        traitBonus += traitStage * 1; // 1 MP Regen per trait level
                        if (traitCalc != '') {
                            traitCalc += ` + `;
                        }
                        traitCalc += `${traitStage} x 1`;
                    }
                } else {
                    //otherwise, gain HP Regen
                    if(stat === "HP Regen"){
                        traitBonus += traitStage * 1; // 1 HP Regen per trait level
                        if (traitCalc != '') {
                            traitCalc += ` + `;
                        }
                        traitCalc += `${traitStage} x 1`;
                    }
                }
            }   
        }
    }
    // 24 - Unnatural Flow - our attacks deal X extra True Damage
    if( selectedTraits[24] && selectedTraits[24] != 0) {
        if(stat === "True Damage" || stat === "Min True Damage" || stat === "Max True Damage" || stat === "Average True Damage Per Hit"){
            let traitStage = parseInt(selectedTraits[24]);
            console.log("Unnatural Flow is selected with level: " + selectedTraits[24]);
            //add traitStage to True Damage
            traitBonus += traitStage;
            if (traitCalc != '') {
                traitCalc += ` + `;
            }
            traitCalc += `${traitStage}`;
        }
    }
    // 25 - Battle Mage - converts 50 Max Mana into 1 extra True Damage
    if( selectedTraits[25] && selectedTraits[25] != "Off") {
        if(stat === "True Damage" || stat === "Min True Damage" || stat === "Max True Damage" || stat === "Average True Damage Per Hit"){
            let traitStage = parseInt(selectedTraits[25]);
            console.log("Battle Mage is selected with level: " + selectedTraits[25]);
            //get total Mana from stats and from items
            let totalMana = statData["Mana"].final;

            console.log(totalMana);
            //divide Mana by 50
            let trueDamageToAdd = Math.floor(totalMana / 50);
            //cap at traitStage
            console.log("Adding True Damage: " + trueDamageToAdd);
            traitBonus += trueDamageToAdd;
            if (traitCalc != '') {
                traitCalc += ` + `;
            }
            traitCalc += `(Floor(${totalMana} / 50)`;
        }
    }
    // 29 - Going Big - Large weapons have X% extra damage
    if( selectedTraits[29] && selectedTraits[29] != "Off") {
        if(stat === "Damage"){
            let traitStage = parseInt(selectedTraits[29]);
            console.log("Going Big is selected with level: " + selectedTraits[29]);
            //get item in left hand
            const itemInHand = document.querySelector('.item-slot[data-slot="hand"] img');
            if (itemInHand && itemInHand.alt) {
                const [name, rarity] = itemInHand.alt.split(';');
                const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                if (item) {
                    //check if item's type contains 'large'
                    const typeOfItem = item[2] || '';
                    if (typeOfItem.includes('large')) {
                        //add traitStage% to Damage
                        traitBonus += Math.floor(item[5] * (traitStage / 100));
                        if (traitCalc != '') {
                            traitCalc += ` + `;
                        }
                        traitCalc += `Floor(${item[5]} x (${traitStage}%))`;
                    }
                }
            }
        }
    }
    //34 - Magic Blade - Removes negative effects from Large Weapons
    if( selectedTraits[34] && selectedTraits[34] != "Off") {
        let traitStage = parseInt(selectedTraits[34]);
        console.log("Magic Blade is selected with level: " + selectedTraits[34]);
        //get item in left hand
        const itemInHand = document.querySelector('.item-slot[data-slot="hand"] img');
        if (itemInHand && itemInHand.alt) {
            const [name, rarity] = itemInHand.alt.split(';');
            const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
            if (item) {
                //check if item's type contains 'large'
                const typeOfItem = item[2] || '';
                if (typeOfItem.includes('large')) {
                    switch(stat){
                        case "Damage":
                            //remove negative damage
                            if(item[5] < 0){
                                traitBonus -= item[5];
                                if (traitCalc != '') {
                                    traitCalc += ` + `;
                                }
                                traitCalc += `(${item[5]} x -1)`;
                            }
                            break;
                        case "Attack Speed":
                            //remove negative attack speed
                            console.log("->ASPD");
                            if(item[13] < 0){
                                console.log("Negative ASPD");
                                traitBonus -= item[13];
                                if (traitCalc != '') {
                                    traitCalc += ` + `;
                                }
                                traitCalc += `(${item[13]} x -1)`;
                            }
                            break;
                        case "Ability":
                            //remove negative ability
                            if(item[8] < 0){
                                traitBonus -= item[8];
                                if (traitCalc != '') {
                                    traitCalc += ` + `;
                                }
                                traitCalc += `(${item[8]} x -1)`;
                            }
                            break;
                        case "Movespeed":
                            //remove negative movespeed
                            if(item[12] < 0){
                                traitBonus -= item[12];
                                if (traitCalc != '') {
                                    traitCalc += ` + `;
                                }
                                traitCalc += `(${item[12]} x -1)`;
                            }
                            break;
                        case "Armor":
                            //remove negative armor
                            if(item[10] < 0){
                                traitBonus -= item[10];
                                if (traitCalc != '') {
                                    traitCalc += ` + `;
                                }
                                traitCalc += `(${item[10]} x -1)`;
                            }
                            break;
                        case "Defense":
                            //remove negative defense
                            if(item[11] < 0){
                                traitBonus -= item[11];
                                if (traitCalc != '') {
                                    traitCalc += ` + `;
                                }
                                traitCalc += `(${item[11]} x -1)`;
                            }
                            break;
                    }
                }
            }
        }
    }
    let jaggedRhythmMaxTrueDmgBonus = 0;
    let jaggedRhythmAvgTrueDmgBonus = 0;
    
    // 38 - Jagged Rhythm - Attacking using a dagger has a X% chance of dealing extra (Ability/4) True Damage
    if( selectedTraits[38] && selectedTraits[38] != "Off") {
        if(stat === "True Damage" || stat === "Max True Damage" || stat === "Average True Damage Per Hit"){
            let traitStage = parseInt(selectedTraits[38]);
            console.log("Jagged Rhythm is selected with level: " + selectedTraits[38]);
            //get item in left hand
            let hasDagger = false;
            const itemsInHands = document.querySelectorAll('.item-slot[data-slot="hand"] img');
            itemsInHands.forEach(itemInHand => {
                if (itemInHand && itemInHand.alt) {
                    const [name, rarity] = itemInHand.alt.split(';');
                    const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                    if (item) {
                        //check if item's type contains 'dagger'
                    const typeOfItem = item[2] || '';
                    if (typeOfItem.includes('dagger')) {
                        hasDagger = true;
                    }
                }
            }
            });
            console.log("Has dagger: " + hasDagger);
            if(hasDagger){
                //add traitStage% of Ability/4 to True Damage
                if(stat === "Average True Damage Per Hit"){
                    jaggedRhythmAvgTrueDmgBonus += (Math.floor(statData["Ability"].final / 4) * (traitStage / 100));
                    traitBonus += jaggedRhythmAvgTrueDmgBonus;
                    final += traitBonus;
                    console.log("ADDING AVG TRUE DAMAGE: " + jaggedRhythmAvgTrueDmgBonus);
                }
                else if (stat === "Max True Damage"){
                    jaggedRhythmMaxTrueDmgBonus += Math.floor((statData["Ability"].final / 4));
                    traitBonus += jaggedRhythmMaxTrueDmgBonus;
                }
                else{
                    
                    traitBonus += Math.floor((statData["Ability"].final / 4));
                    if (traitCalc != '') {
                        traitCalc += ` + `;
                    }
                    traitCalc += `Floor(${statData["Ability"].final} / 4 x (${traitStage}%))`;
                }
            }
        }
    }
    // 39 - Luck Foreseen - Converts every 6 Ability into 1% chance of attacking twice
    let luckForeseenDpsBonus = 0;
    if( selectedTraits[39] && selectedTraits[39] != "Off") {
        if(stat === "Average Damage Per Hit"){
            let traitStage = parseInt(selectedTraits[39]);
            console.log("Luck Foreseen is selected with level: " + selectedTraits[39]);
            //get total Ability from stats and from items
            let totalAbility = statData["Ability"].statBonus + statData["Ability"].itemBonus;
            console.log("Stat bonus: " + statData["Ability"].statBonus + " Item Bonus: " + statData["Ability"].itemBonus + " Total Ability: " + totalAbility);
            //divide Ability by 6
            let abilityToAdd = Math.floor(totalAbility / 6);
            //cap at traitStage
            luckForeseenDpsBonus += abilityToAdd;
        }
    }
    // 40 - Dark Blade - Doubles all True Damage you deal
    if (selectedTraits[40] && selectedTraits[40] != "Off") {
        if(stat === "True Damage" || stat === "Min True Damage" || stat === "Max True Damage" || stat === "Average True Damage Per Hit"){
            console.log("Dark Blade is selected with level: " + selectedTraits[40]);
            //double trait bonus
            traitBonus *= 2;
            if (traitCalc != '') {
                traitCalc = `[${traitCalc}] x 2`;
            }
        }
    }
    //42 - Double Danger - Using two daggers doubles your item damage
    if (selectedTraits[42] && selectedTraits[42] != "Off") {
        if(stat === "Damage"){
            let daggerCount = 0;
            const itemsInHands = document.querySelectorAll('.item-slot[data-slot="hand"] img');
            itemsInHands.forEach(itemInHand => {
                const [name, rarity] = itemInHand.alt.split(';');
                const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                if (item) {
                    //check if item's type contains 'dagger'
                    const typeOfItem = item[2] || '';
                    if (typeOfItem.includes('dagger')) {
                        daggerCount++;
                    }
                }
            });
            if (daggerCount >= 2) {
                console.log("Double Danger is active");
                traitBonus = itemBonus;
                if (traitCalc != '') {
                    traitCalc += " + ";
                }
                traitCalc = `[${itemCalc}]`;
            }
        }
    }
    //43 - "Bow Guidance" - "Bows have X extra Attackspeed"
    if(selectedTraits[43] && selectedTraits[43] != "Off") {
        if(stat === "Attack Speed"){
            let usingBow = false;
            //check if item in any hand type == bow
            const itemInHand = document.querySelectorAll('.item-slot[data-slot="hand"] img');
            if (itemInHand[0] && itemInHand[0].alt) {
                const [name, rarity] = itemInHand[0].alt.split(';');
                const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                if (item) {
                    //name	 slot	 type	 weight	 range	 DMG	 hp     mana	ability	 magic	 arm	 def	 moveS	 atkSpd	 ??
                    if(item[2] === 'bow'){  
                        usingBow = true;
                    }
                }
            }
            if (itemInHand[1] && itemInHand[1].alt) {
                const [name, rarity] = itemInHand[1].alt.split(';');
                const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                if (item) {
                    //name	 slot	 type	 weight	 range	 DMG	 hp     mana	ability	 magic	 arm	 def	 moveS	 atkSpd	 ??
                    if(item[2] === 'bow'){
                        usingBow = true;
                    }
                }
            }
            if (usingBow){
                console.log("Bow Guidance is selected with level: " + selectedTraits[43]);
                //add trait bonus
                traitBonus += parseInt(selectedTraits[43]);
                if (traitCalc != '') {
                    traitCalc += " + ";
                }
                traitCalc += traitBonus;
            }
        }
    }
    //44 - Good Technique" - "Gain X extra Range"
    if (selectedTraits[44] && selectedTraits[44] != "Off") {
        if(stat === "Range"){
            console.log("Good Technique is selected with level: " + selectedTraits[44]);
            //add trait bonus
            traitBonus += parseInt(selectedTraits[44]);
            if (traitCalc != '') {
                traitCalc += " + ";
            }
            traitCalc += traitBonus;
        }
    }
    //45 - "Artisenal Arsenal" - "Non-magic arrow get +X Damage and break less often"
    if (selectedTraits[45] && selectedTraits[45] != "Off") {
        if(stat === "Damage"){
            let hasNormalAmmo = false;
            //check if item in ammoslot == normalAmmo
            const ammoSlot = document.querySelector('.item-slot[data-slot="ammo"] img');
            if (ammoSlot && ammoSlot.alt) {
                const [name, rarity] = ammoSlot.alt.split(';');
                const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                if (item) {
                    //name	 slot	 type	 weight	 range	 DMG	 hp     mana	ability	 magic	 arm	 def	 moveS	 atkSpd	 ??
                    if(item[2] === 'normalAmmo'){
                        hasNormalAmmo = true;
                    }
                }
            }
            if(hasNormalAmmo){
                console.log("Artisenal Arsenal is selected with level: " + selectedTraits[45]);
                //add trait bonus
                traitBonus += parseInt(selectedTraits[45]);
                if (traitCalc != '') {
                    traitCalc += " + ";
                }
                traitCalc += traitBonus;
            }
        }
    }
    //46 - "Tunnelvision" - "Gain 10 Attackspeed"
    if (selectedTraits[46] && selectedTraits[46] != "Off") {
        if(stat === "Attack Speed"){
            console.log("Tunnelvision is selected with level: " + selectedTraits[46]);
            //add trait bonus
            traitBonus += parseInt(selectedTraits[46]);
            if (traitCalc != '') {
                traitCalc += " + ";
            }
            traitCalc += traitBonus;
        }
    }
    // 50 - "Cozy and Useful" - "Get X extra mana for every piece of light armor you wear",
    if (selectedTraits[50] && selectedTraits[50] != "Off") {
        if(stat === "Mana"){
            console.log("Cozy and Useful is selected with level: " + selectedTraits[50]);
            //get all items in armor slots
            const armorSlots = document.querySelectorAll('.item-slot img');
            let lightArmorCount = 0;
            armorSlots.forEach(armorSlot => {
                if (armorSlot && armorSlot.alt) {
                    const [name, rarity] = armorSlot.alt.split(';');
                    const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                    if (item) {
                        //name	 slot	 type	 weight	 range	 DMG	 hp     mana	ability	 magic	 arm	 def	 moveS	 atkSpd	 ??
                        if(item[2].includes('light')){
                            lightArmorCount++;
                        }
                    }
                }
            });
            console.log("Light armor count: " + lightArmorCount);

            //add trait bonus
            traitBonus += parseInt(selectedTraits[50]) * lightArmorCount;
            if (traitCalc != '') {
                traitCalc += " + ";
            }
            traitCalc += `${parseInt(selectedTraits[50])} x ${lightArmorCount}`;
        }
    }
    // 51 - "Lightfoot" - "Converts X Free Capacity into 1 Movespeed capping at 3"
    if (selectedTraits[51] && selectedTraits[51] != "Off") {
        if(stat === "Movespeed"){
            console.log("Lightfoot is selected with level: " + selectedTraits[51]);
            //get free capacity from stats
            let freeCapacity = statData["Capacity Free"].final;
            //divide free capacity by traitStage
            let movespeedToAdd = Math.floor(freeCapacity / parseInt(selectedTraits[51]));
            //cap at 3
            movespeedToAdd = Math.min(movespeedToAdd, 3);
            traitBonus += movespeedToAdd;
            if (traitCalc != '') {
                traitCalc += ` + `;
            }
            traitCalc += `Min(floor(${freeCapacity} / ${selectedTraits[51]}), 3)`;
        }
    }
    // 52 - Dress Wizardly" - "Light Armor that weighs less than X oz gives you +1 Magic"
    if (selectedTraits[52] && selectedTraits[52] != "Off") {
        if(stat === "Magic"){
            console.log("Dress Wizardly is selected with level: " + selectedTraits[52]);
            //get all items in armor slots
            const armorSlots = document.querySelectorAll('.item-slot img');
            let lightArmorCount = 0;
            //check each slot if it contains "light" in its type and weight is less than traitStage
            armorSlots.forEach(armorSlot => {
                console.log("Checking armor slot: ", armorSlot);
                if (armorSlot && armorSlot.alt) {
                    const [name, rarity] = armorSlot.alt.split(';');
                    const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                    if (item) {
                        //name	 slot	 type	 weight	 range	 DMG	 hp     mana	ability	 magic	 arm	 def	 moveS	 atkSpd	 ??
                        if(item[2].includes('light') && (item[3]/10) < parseInt(selectedTraits[52])){
                            lightArmorCount++;
                        }
                    }
                }
            });
            console.log("Light armor count: " + lightArmorCount);

            //add trait bonus
            traitBonus += lightArmorCount;
            if (traitCalc != '') {
                traitCalc += " + ";
            }
            traitCalc += `${lightArmorCount}`;
        }
    }
    //53 - Clothes of the Damned" - "Removes negative effects from Light Armor and gain 5% Magic for each equipped Light Armor."
    let clothesOfTheDamnedPercentBonus = 0;
    if (selectedTraits[53] && selectedTraits[53] != "Off") {
        console.log("Clothes of the Damned is selected with level: " + selectedTraits[53]);
        //get all items in armor slots
        const armorSlots = document.querySelectorAll('.item-slot img');
        let lightArmorCount = 0;
        //check each slot if it contains "light" in its type
        armorSlots.forEach(armorSlot => {
            if (armorSlot && armorSlot.alt) {
                const [name, rarity] = armorSlot.alt.split(';');
                const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                if (item) {
                    
                    const typeOfItem = item[2] || '';
                    if (typeOfItem.includes('light')) {
                        switch(stat){

            //name	 slot	 type	 weight	 range	 DMG	 hp	 mana	ability	 magic	 arm	 def	 moveS	 atkSpd	 ??	 eqSize	HP reg	MP reg	 description 	rarity
                            case "Damage":
                                //remove negative damage
                                if(item[5] < 0){
                                    traitBonus -= item[5];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[5]} x -1)`;
                                }
                                break;
                            case "Attack Speed":
                                //remove negative attack speed
                                console.log("->ASPD");
                                if(item[13] < 0){
                                    console.log("Negative ASPD");
                                    traitBonus -= item[13];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[13]} x -1)`;
                                }
                                break;
                            case "Ability":
                                //remove negative ability
                                if(item[8] < 0){
                                    traitBonus -= item[8];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[8]} x -1)`;
                                }
                                break;
                            case "Movespeed":
                                //remove negative movespeed
                                if(item[12] < 0){
                                    traitBonus -= item[12];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[12]} x -1)`;
                                }
                                break;
                            case "Armor":
                                //remove negative armor
                                if(item[10] < 0){
                                    traitBonus -= item[10];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[10]} x -1)`;
                                }
                                break;
                            case "Defense":
                                //remove negative defense
                                if(item[11] < 0){
                                    traitBonus -= item[11];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[11]} x -1)`;
                                }
                                break;
                            case "Health":
                                //remove negative health
                                if(item[6] < 0){
                                    traitBonus -= item[6];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[6]} x -1)`;
                                }
                                break;
                            case "Mana":
                                //remove negative mana
                                if(item[7] < 0){
                                    traitBonus -= item[7];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[7]} x -1)`;
                                }
                                break;
                            case "Magic":
                                //remove negative magic
                                if(item[9] < 0){
                                    traitBonus -= item[9];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[9]} x -1)`;
                                }
                                clothesOfTheDamnedPercentBonus += 5; // 5% Magic for each equipped Light Armor
                                break;
                        }
                    }
                }
            }
        });
        if(stat === "Magic"){
            if(clothesOfTheDamnedPercentBonus > 0){
                //get total Magic from stats, items and traits
                let totalMagic = statData["Magic"].statBonus + statData["Magic"].itemBonus + traitBonus;
                console.log("Total Magic: " + totalMagic);
                //add clothesOfTheDamnedPercentBonus% to Magic
                traitBonus += Math.floor(totalMagic * (clothesOfTheDamnedPercentBonus/100));
                if (traitCalc != '') {
                    traitCalc += ` + `;
                }
                traitCalc += `(${traitBonus})`;
            }
        }
    }
    //55 - Breeze in your hair - Not wearing a "helmet" type gives you +X Movespeed
    if(selectedTraits[55] && selectedTraits[55] != "Off" && selectedTraits[55] != 0) {
        //check the type of item in head slot
        if(stat === "Movespeed"){
            console.log("Breeze in your hair is selected with level: " + selectedTraits[55]);
            const headSlot = document.querySelector('.item-slot[data-slot="head"] img');
            let headType = '';
            let noHelmet = false;
            if (headSlot && headSlot.alt) {
                const [name, rarity] = headSlot.alt.split(';');
                const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                if (item) {
                    //name	 slot	 type	 weight	 range	 DMG	 hp     mana	ability	 magic	 arm	 def	 moveS	 atkSpd	 ??
                    headType = item[2] || '';
                    if (!headType.includes('helmet')) {
                        // If the head item is a helmet, apply the bonus
                        noHelmet = true;
                    }
                }
            }
            else{
                // If there is no item in the head slot, apply the bonus
                noHelmet = true;
            }
            if (noHelmet) {
                //add trait bonus
                traitBonus += parseInt(selectedTraits[55]);
                if (traitCalc != '') {
                    traitCalc += " + ";
                }
                traitCalc += traitBonus;
            }
        }
    }
    //56 - "Battle Boots" - "Gives 2 Damage for every extra Movespeed"
    if(selectedTraits[56] && selectedTraits[56] != "Off" && selectedTraits[56] != 0) {
        console.log("Battle Boots is selected with level: " + selectedTraits[56]);
        if(stat === "Damage"){
            // Get the current Movespeed
            let bonusMovespeed = (statData["Movespeed"].final - 35) || 0;
            // Calculate the bonus damage
            let bonusDamage = Math.floor(bonusMovespeed) * 2;
            traitBonus += bonusDamage;
            if (traitCalc != '') {
                traitCalc += ` + `;
            }
            traitCalc += `(${bonusDamage})`;
        }
    }
    //57 - Block Efficiacy - Shields have X% extra defense
    if(selectedTraits[57] && selectedTraits[57] != "Off" && selectedTraits[57] != 0) {
        console.log("Block Efficiacy is selected with level: " + selectedTraits[57]);
        if(stat === "Defense"){
            //check if item in left hand is a shield
            const itemsInHands = document.querySelectorAll('.item-slot[data-slot="hand"] img');
            itemsInHands.forEach(itemInHand => {
                if (itemInHand && itemInHand.alt) {
                    const [name, rarity] = itemInHand.alt.split(';');
                    const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                    if (item) {
                        //name	 slot	 type	 weight	 range	 DMG	 hp     mana	ability	 magic	 arm	 def	 moveS	 atkSpd	 ??
                        if(item[2].includes('shield')){
                            //add trait bonus
                            traitBonus += Math.max(1,Math.floor(item[11] * (selectedTraits[57] / 100)));
                            if (traitCalc != '') {
                                traitCalc += ` + `;
                            }
                            traitCalc += `Max(1, Floor(${item[11]} x (${selectedTraits[57]}%)))`;
                        }
                    }
                }
            });
        }
    }
    //63 - Monster Candy - Lose 99 Damage
    if(selectedTraits[63] && selectedTraits[63] != "Off" && selectedTraits[63] != 0) {
        console.log("Monster Candy is selected with level: " + selectedTraits[63]);
        if(stat === "Damage"){
            //subtract 99 from Damage
            traitBonus -= 99;
            if (traitCalc != '') {
                traitCalc += ` - `;
            }
            traitCalc += `99`;
        }
    }
    // 64 - "Well Protected","Heavy Armor has X extra health"
    if(selectedTraits[64] && selectedTraits[64] != "Off" && selectedTraits[64] != 0) {
        console.log("Well Protected is selected with level: " + selectedTraits[64]);
        if(stat === "Health"){
            //count all items with "heavy" in their type
            const armorSlots = document.querySelectorAll('.item-slot img');
            let heavyArmorCount = 0;
            armorSlots.forEach(armorSlot => {
                if (armorSlot && armorSlot.alt) {
                    const [name, rarity] = armorSlot.alt.split(';');
                    const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                    if (item) {
                        //name	 slot	 type	 weight	 range	 DMG	 hp     mana	ability	 magic	 arm	 def	 moveS	 atkSpd	 ??
                        if(item[2].includes('heavy')){
                            heavyArmorCount++;
                        }
                    }
                }
            });
            //add trait bonus
            traitBonus += parseInt(selectedTraits[64]) * heavyArmorCount;
            if (traitCalc != '') {
                traitCalc += ` + `;
            }
            traitCalc += `${parseInt(selectedTraits[64])} x ${heavyArmorCount}`;
        }
    }
    // 65 - Heavy Metal - Heavy Armor that weighs more than X oz. has 1 Ability extra
    if(selectedTraits[65] && selectedTraits[65] != "Off" && selectedTraits[65] != 0) {
        if(stat === "Ability"){
            console.log("Heavy Metal is selected with level: " + selectedTraits[65]);
            //count all heavy armor items that weigh more than X oz.
            const armorSlots = document.querySelectorAll('.item-slot img');
            let heavyArmorCount = 0;
            armorSlots.forEach(armorSlot => {
                if (armorSlot && armorSlot.alt) {
                    const [name, rarity] = armorSlot.alt.split(';');
                    const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                    if (item) {
                        //name	 slot	 type	 weight	 range	 DMG	 hp     mana	ability	 magic	 arm	 def	 moveS	 atkSpd	 ??
                        if(item[2].includes('heavy') && (item[3]/10) > selectedTraits[65]) {
                            heavyArmorCount++;
                        }
                    }
                }
            });
            //add trait bonus
            traitBonus += heavyArmorCount;
            if (traitCalc != '') {
                traitCalc += ` + `;
            }
            traitCalc += `${heavyArmorCount}`;
        }
    }
    //67 - Blessed Plate - Heavy Armor has 1 Magic and 25 Mana extra
    if(selectedTraits[67] && selectedTraits[67] != "Off" && selectedTraits[67] != 0) {
        if(stat === "Magic" || stat === "Mana"){
            console.log("Blessed Plate is selected with level: " + selectedTraits[67]);
            //count all heavy armor items
            const armorSlots = document.querySelectorAll('.item-slot img');
            let heavyArmorCount = 0;
            armorSlots.forEach(armorSlot => {
                if (armorSlot && armorSlot.alt) {
                    const [name, rarity] = armorSlot.alt.split(';');
                    const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                    if (item) {
                        //name	 slot	 type	 weight	 range	 DMG	 hp     mana	ability	 magic	 arm	 def	 moveS	 atkSpd	 ??
                        if(item[2].includes('heavy')) {
                            heavyArmorCount++;
                        }
                    }
                }
            });
            //add trait bonus
            if(stat === "Magic"){
                traitBonus += heavyArmorCount;
                if (traitCalc != '') {
                    traitCalc += ` + `;
                }
                traitCalc += `${heavyArmorCount}`;
            }
            if(stat === "Mana"){
                traitBonus += heavyArmorCount * 25;
                if (traitCalc != '') {
                    traitCalc += ` + `;
                }
                traitCalc += `${heavyArmorCount} x 25`;
            }
        }
    }   


    //68 - "Carry Your Might - "Gain 1 Armor for every 100 Max Capacity, capping at X"
    if(selectedTraits[68] != "Off" && selectedTraits[68]) {
        if(stat === "Armor"){
            let traitStage = parseInt(selectedTraits[68]);
            console.log("Carry Your Might is selected with level: " + selectedTraits[68]);
            //get Capacity 
            let totalCapacity = statData["Capacity"].final;
            //divide Capacity by 100
            let capacityToAdd = Math.ceil(totalCapacity / 100);

            //cap at traitStage
            capacityToAdd = Math.min(capacityToAdd, traitStage);
            traitBonus += capacityToAdd;
            if (traitCalc != '') {
                traitCalc += ` + `;
            }
            traitCalc += `Min(Floor(${totalCapacity} / 100), ${traitStage})`;
        }
    }
    // 69 - "Juggernaut","Removes negative effects from Heavy Armor. Gain 5% Ability for each equipped Heavy Armor."
    let juggernautPercentBonus = 0;
    if(selectedTraits[69] && selectedTraits[69] != "Off" && selectedTraits[69] != 0) {
        console.log("Juggernaut is selected with level: " + selectedTraits[69]);
        //get all items in armor slots
        const armorSlots = document.querySelectorAll('.item-slot img');
        let heavyArmorCount = 0;
        //check each slot if it contains "heavy" in its type
        armorSlots.forEach(armorSlot => {
            if (armorSlot && armorSlot.alt) {
                const [name, rarity] = armorSlot.alt.split(';');
                const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                if (item) {
                    const typeOfItem = item[2] || '';
                    if (typeOfItem.includes('heavy')) {
                        switch(stat){
                            //name	 slot	 type	 weight	 range	 DMG	 hp     mana    ability	 magic	 arm	 def	 moveS	 atkSpd	 ??	 eqSize     HP reg	MP reg	 description 	rarity  
                            case "Damage":
                                //remove negative damage
                                if(item[5] < 0){
                                    traitBonus -= item[5];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[5]} x -1)`;
                                }
                                break;
                            case "Attack Speed":
                                //remove negative attack speed
                                if(item[13] < 0){
                                    traitBonus -= item[13];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[13]} x -1)`;
                                }
                                break;
                            case "Ability":
                                //remove negative ability
                                if(item[8] < 0){
                                    traitBonus -= item[8];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[8]} x -1)`;
                                }
                                break;
                            case "Movespeed":
                                //remove negative movespeed
                                if(item[12] < 0){
                                    traitBonus -= item[12];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[12]} x -1)`;
                                }
                                break;
                            case "Armor":
                                //remove negative armor
                                if(item[10] < 0){
                                    traitBonus -= item[10];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[10]} x -1)`;
                                }
                                break;
                            case "Defense":
                                //remove negative defense
                                if(item[11] < 0){
                                    traitBonus -= item[11];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[11]} x -1)`;
                                }
                                break;
                            case "Health":
                                //remove negative health
                                if(item[6] < 0){
                                    traitBonus -= item[6];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[6]} x -1)`;
                                }
                                break;
                            case "Mana":
                                //remove negative mana
                                if(item[7] < 0){
                                    traitBonus -= item[7];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[7]} x -1)`;
                                }
                                break;
                            case "Magic":
                                //remove negative magic
                                if(item[9] < 0){
                                    traitBonus -= item[9];
                                    if (traitCalc != '') {
                                        traitCalc += ` + `;
                                    }
                                    traitCalc += `(${item[9]} x -1)`;
                                }
                                break;
                        }
                        heavyArmorCount++;
                    }
                }
            }
        });
        if(stat === "Ability"){
            if(heavyArmorCount > 0){
                //get total Ability from stats, items and traits
                let totalAbility = statData["Ability"].statBonus + statData["Ability"].itemBonus + traitBonus;
                console.log("Total Ability: " + totalAbility);
                //add juggernautPercentBonus% to Ability
                juggernautPercentBonus += 5 * heavyArmorCount; // 5%
                traitBonus += Math.floor(totalAbility * (juggernautPercentBonus/100));
                if (traitCalc != '') {
                    traitCalc += ` + `;
                }
                traitCalc += `(${traitBonus})`;
            }
        }
    }
    //70 - "Endowed in Steel"- "Using gloves in both your hands gives you +10% lifesteal, +23 Damage, +13 Ability and +7 Attack Speed"
    if (selectedTraits[70] && selectedTraits[70] != "Off") {
        console.log("Endowed in Steel is selected with level: " + selectedTraits[70]);
        //check if item in both hands is a glove
        const itemsInHands = document.querySelectorAll('.item-slot[data-slot="hand"] img');
        let glovesCounter = 0;
        itemsInHands.forEach(itemInHand => {
            if (itemInHand && itemInHand.alt) {
                const [name, rarity] = itemInHand.alt.split(';');
                const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                if (item) {
                    //name	 slot	 type	 weight	 range	 DMG	 hp     mana	ability	 magic	 arm	 def	 moveS	 atkSpd	 ??
                    if(item[2].includes('glove')){
                        glovesCounter++;
                    }
                }
            }
        });
        if (glovesCounter >= 2) {
            //add trait bonus
            if(stat === "Damage"){
                if(traitCalc != '') {
                    traitCalc += ` + `;
                }
                traitCalc += '23';
                traitBonus += 23; // damage
            }
            if(stat === "Ability"){
                if(traitCalc != '') {
                    traitCalc += ` + `;
                }
                traitCalc += '13';
                traitBonus += 13; // ability
            }
            if(stat === "Attack Speed"){
                if(traitCalc != '') {
                    traitCalc += ` + `;
                }
                traitCalc += '7';   // attack speed
                traitBonus += 7; // attack speed
            }
        }
    }
    if(stat === "Range"){
        console.log("RANGE1111!!!!!!!!!!!!!!!!!!!!!!!!!! Baze "+baseValue);
        console.log("RANGE2222!!!!!!!!!!!!!!!!!!!!!!!!!! Baze "+baseValues["Range"]);
        console.log("RANGE3333!!!!!!!!!!!!!!!!!!!!!!!!!! item1 "+itemBonus);
        console.log("RANGE3333!!!!!!!!!!!!!!!!!!!!!!!!!! item2 "+statData["Range"].itemBonus);
    }
    //---------------------------------------------------
    //---------------------------------------------------
    //---------------------------------------------------
    //---------------------------------------------------
    //----- Traits calculation FINISH:-----
    //---------------------------------------------------
    //---------------------------------------------------
    //---------------------------------------------------
    if (traitCalc != ''){
        traitCalc =  `[`+traitCalc+`] x ${multiplier}`;
    }
    traitBonus = (traitBonus * classMult).toFixed(2);

    statData[stat].statBonus = parseInt(statBonus);
    statData[stat].itemBonus = parseInt(itemBonus);
    statData[stat].traitBonus = traitBonus;
    final = (parseInt(baseValue) + parseFloat(statBonus) + parseFloat(itemBonus) + parseFloat(traitBonus));
    statData[stat].final = final;
    //-----------------------------
    rowClass = 'stat-container';
    
    //Exception for Damage which has range
    let minDamage = 0;
    let maxDamage = 0;
    let dphValue = 0;
    let damageRangeString = '';

    //Exception for Range
    if(stat == "Range"){
        console.log("RANGE!!!!!!!!!!!!!!!!!!!!!!!!!! base "+baseValues["Range"]);
        console.log("RANGE!!!!!!!!!!!!!!!!!!!!!!!!!! item "+statData["Range"].itemBonus);
        console.log("RANGE!!!!!!!!!!!!!!!!!!!!!!!!!! final:"+final+" and range:"+statData["Range"].final);
        //minRange = (parseInt(final))/(5/(1+((parseInt(statData["Ability"].final)*1.25)/100)));
    }
    //Exception for Magic
    if(stat == "Damage"){
        console.log("final:"+final+" and ability:"+statData["Ability"].final);
        minDamage = (parseInt(final))/(5/(1+((parseInt(statData["Ability"].final)*1.25)/100)));
        console.log("minDamage:"+minDamage);
        maxDamage = (parseInt(final))*(1+(parseInt(statData["Ability"].final)*1.25)/100);
        console.log("maxDamage:"+maxDamage);
        damageRangeString = '<span class="grey"> ('+minDamage.toFixed(0)+"-"+maxDamage.toFixed(0)+')</span>';
        dphValue = (minDamage + maxDamage) / 2;
        //final += damageRangeString;
    }
    //Exception for Min Damage
    if(stat === "Min Damage"){
        multiplier = '';
        baseValue = '';
        added = '';
        statCalc = '';
        statBonus = '';
        itemCalc = '';
        itemBonus = '';
        traitCalc = '';
        traitBonus = '';
        final = (parseFloat(statData["Damage"].final))/(5/(1+((parseFloat(statData["Ability"].final)*1.25)/100)));
        statData[stat].final = final;
    }
    //Exception for Max Damage
    if(stat === "Max Damage"){
        multiplier = '';
        baseValue = '';
        added = '';
        statCalc = '';
        statBonus = '';
        itemCalc = '';
        itemBonus = '';
        traitCalc = '';
        traitBonus = '';
        final = (parseFloat(statData["Damage"].final))*(1+(parseFloat(statData["Ability"].final)*1.25)/100);
        statData[stat].final = final;
    }
    //Exception for Average Damage Per Hit
    if(stat === "Average Damage Per Hit"){
        stat = "Avg Dmg Per Hit";
        multiplier = '';
        baseValue = '';
        added = '';
        statCalc = '';
        statBonus = '';
        itemCalc = '';
        itemBonus = '';
        traitCalc = '';
        traitBonus = '';
        final = ((statData["Min Damage"].final + statData["Max Damage"].final) / 2);
        console.log("Luck foreseen bonus: " + luckForeseenDpsBonus);
        final *= (1 + luckForeseenDpsBonus/100);
        statData["Average Damage Per Hit"].final = final;
    }
    //Exception for Bow Damage
    if(stat === "Bow Damage"){
        multiplier = '';
        baseValue = '';
        added = '';
        statCalc = '';
        statBonus = '';
        itemCalc = '';
        itemBonus = '';
        traitCalc = '';
        traitBonus = '';
        //check if item in any hand type == bow
        const itemInHand = document.querySelectorAll('.item-slot[data-slot="hand"] img');
        let hasBow = false;
        if (itemInHand[0] && itemInHand[0].alt) {
            const [name, rarity] = itemInHand[0].alt.split(';');
            const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
            if (item) {
                //name	 slot	 type	 weight	 range	 DMG	 hp     mana	ability	 magic	 arm	 def	 moveS	 atkSpd	 ??     eqSize	HP reg	MP reg	 description 	rarity
                if(item[2] === 'bow'){
                    hasBow = true;
                }
            }
        }
        if (itemInHand[1] && itemInHand[1].alt) {
            const [name, rarity] = itemInHand[1].alt.split(';');
            const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
            if (item) {
                //name	 slot	 type	 weight	 range	 DMG	 hp     mana	ability	 magic	 arm	 def	 moveS	 atkSpd	 ??
                if(item[2] === 'bow'){
                    hasBow = true;
                }
            }
        }
        if (hasBow) {
            //get bow damage from stats and items
            final += getBowDamage();
        }

        console.log("1---> Bow Damage FINAL: " + statData["Bow Damage"].final);
        statData[stat].final = final;
    }
    if(stat === "True Damage"){
        multiplier = '';
        baseValue = '';
        added = '';
        statCalc = '';
        statBonus = '';
        itemCalc = '';
        itemBonus = '';
        //traitCalc = '';
        //traitBonus = '';
        statData[stat].traitCalc = traitCalc;
        statData[stat].final = final.toFixed(2);
    }
    if(stat === "Min True Damage"){
        multiplier = '';
        baseValue = '';
        added = '';
        statCalc = '';
        statBonus = '';
        itemCalc = '';
        itemBonus = '';
        traitCalc = '';
        traitBonus = '';
        statData[stat].final = final.toFixed(2);
    }
    if(stat === "Max True Damage"){
        multiplier = '';
        baseValue = '';
        added = '';
        statCalc = '';
        statBonus = '';
        itemCalc = '';
        itemBonus = '';
        traitCalc = statData["True Damage"].traitCalc || '';
        //traitCalc = '';
        statData[stat].final = final.toFixed(2);
    }

    if(stat === "Average True Damage Per Hit"){
        stat = "Avg True Dmg Per Hit";
        multiplier = '';
        baseValue = '';
        added = '';
        statCalc = '';
        statBonus = '';
        itemCalc = '';
        itemBonus = '';
        traitCalc = '';
        //get min and max true damage
        //calculate average true damage per hit
        statData["Average True Damage Per Hit"].final = final;
    }
    //Exception for DPS, which is not allocatable
    if (stat === "DPS") {
        multiplier = '';
        baseValue = '';
        added = '';
        statCalc = '';
        statBonus = '';
        itemCalc = '';
        itemBonus = '';
        traitCalc = '';
        console.log("Aspd from dps point: " + statData["Attack Speed"].final);
        //1. Get avg DMG Per Hit - if bow > 0, then use (Bow Damage/2), otherwise use Average Damage Per Hit
        //2. Get avg True Damage Per Hit
        //3. Get Attack Speed
        //4. Calculate DPS = (Avg DMG Per Hit + Avg True Damage Per Hit) * (Attack Speed / 10)
        let avgDmgPerHit = 0;
            console.log("---> Bow Damage FINAL: " + statData["Bow Damage"].final);
        if(statData["Bow Damage"].final > 0){
            avgDmgPerHit = ((statData["Bow Damage"].final || 0) / 2) + (statData["Average True Damage Per Hit"].final || 0);
        }
        else{
            avgDmgPerHit += (statData["Average Damage Per Hit"].final || 0) + (statData["Average True Damage Per Hit"].final || 0);
        }
        const attackSpeed = statData["Attack Speed"].final || 10; // Default to 10 if not set
        final = (avgDmgPerHit * (attackSpeed / 10)).toFixed(2);
    }
    if(stat === "Capacity Used"){
        multiplier = '';
        baseValue = '';
        added = '';
        statCalc = '';
        statBonus = '';
        traitCalc = '';
        traitBonus = '';
    }
    if(stat === "Capacity Free"){
        multiplier = '';
        baseValue = '';
        added = '';
        statCalc = '';
        statBonus = '';
        traitCalc = '';
        traitBonus = '';
    }

    if(stat === "True Damage") return ""; //Skip row print for true damage

    return `<div class=\"${rowClass}\">
        <div>${stat}</div>
        <div>${multiplier}</div>
        <div>${baseValue}</div>
        <div>${canAllocate && added > 0 ? `<button class="stats" onclick='subtractPoint(\"${stat}\")'><img class="minus" src="Icons/minus.png"></button>` : ''}</div>
        <div>${canAllocate && (availablePoints > 0 && added < selectedLevel) ? `<button class="stats" onclick='addPoint(\"${stat}\")'><img class="plus" src="Icons/plus.png"></button>` : ''}</div>
        <div>${added}</div>
        <div><marquee width="50px" scrollamount="3" onmouseover="this.stop();" onmouseout="this.start();">${statCalc}</marquee></div>
        <div>${statBonus}</div>
        <div><marquee width="50px" scrollamount="3" onmouseover="this.stop();" onmouseout="this.start();">${itemCalc}</marquee></div>
        <div>${itemBonus}</div>
        <div style='min-width:120px;'><marquee width="210px" scrollamount="3" onmouseover="this.stop();" onmouseout="this.start();">${traitCalc}</marquee></div>
        <div style='min-width:60px;'>${traitBonus}</div>
        <div>${parseFloat(final).toFixed(2)}</div>
    </div>`;

    // Recalculate final value
}
// Hook stat table update to level and class selection
(function() {
    const origUpdateDebug = window.updateDebug;
    window.updateDebug = function() {
        if(origUpdateDebug) origUpdateDebug();
        updateStatTable();
        updateStatTable();
    };
})();
window.addEventListener('DOMContentLoaded', function() {
    updateStatTable();
    updateStatTable();
    renderMiniTraitTree();
});
function addPoint(stat) {
    const level = selectedLevel;
    if (availablePoints > 0 && addedPoints[stat] < level) {
        addedPoints[stat]++;
        updateStatTable();
        updateStatTable();
    }
}
function subtractPoint(stat) {
    if (addedPoints[stat] > 0) {
        addedPoints[stat]--;
        updateStatTable();
        updateStatTable();
    }
}
// --- TRAIT TREE LOGIC (ported from calc.html, adapted for calc2.html) ---
let selectedTraits = {};
let availableTraitPoints = 0;
function renderTraitTree() {
    const traitTreeUI = document.getElementById('trait-tree-ui');
    traitTreeUI.innerHTML = '';
    // Add trait points counter
    const pointsDiv = document.createElement('div');
    pointsDiv.style.position = 'absolute';
    pointsDiv.style.top = '10px';
    pointsDiv.style.left = '10px';
    pointsDiv.style.fontSize = '1.2em';
    pointsDiv.innerHTML = `Trait Points: <span id="available-trait-points">${availableTraitPoints}</span>`;
    traitTreeUI.appendChild(pointsDiv);
    // Main panel
    const traitsPanel = document.createElement('div');
    traitsPanel.className = 'traits-panel';
    traitsPanel.id = 'traits-panel';
    traitsPanel.style.width = '100%';
    traitsPanel.style.height = '100%';
    traitsPanel.style.position = 'relative';
    // List container
    const traitsList = document.createElement('div');
    traitsList.id = 'traits-list';
    traitsPanel.appendChild(traitsList);
    traitTreeUI.appendChild(traitsPanel);
    // Draw connectors first, as first children of traitsPanel (before traitsList)
    const connectorSvgs = [];
    traits.forEach(trait => {
        if (trait[0] === 0) return; // Skip root trait
        if (trait[1] > -1) {
            const parentTrait = traits.find(t => t[0] === trait[1]);
            if (parentTrait) {
                const locationMultiplierX = 0.35;
                const locationMultiplierY = 0.35;
                const centerSpot = [500, 350];
                const traitX = (centerSpot[0] + trait[9]) * locationMultiplierX + 12;
                const traitY = (centerSpot[1] + trait[10]) * locationMultiplierY + 13;
                const parentX = (centerSpot[0] + parentTrait[9]) * locationMultiplierX + 12;
                const parentY = (centerSpot[1] + parentTrait[10]) * locationMultiplierY + 13;
                let differenceBetweenX = traitX - parentX;
                let differenceBetweenY = traitY - parentY;
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                let startX = 0;
                               let startY = 0;
                if(differenceBetweenX < 0){ startX = Math.abs(differenceBetweenX) * 2; }
                if(differenceBetweenY < 0){ startY = Math.abs(differenceBetweenY) * 2; }
                line.setAttribute("x1", startX);
                line.setAttribute("y1", startY);
                line.setAttribute("x2", Math.abs(differenceBetweenX) + 3);
                line.setAttribute("y2", Math.abs(differenceBetweenY) + 3);
                line.setAttribute('stroke', '#444');
                line.setAttribute('stroke-width', '2');
                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                svg.style.position = 'absolute';
                svg.style.left = (traitX-Math.abs(differenceBetweenX))+ 'px';
                svg.style.top = (traitY-Math.abs(differenceBetweenY))+ 'px';
                svg.style.width = (2*Math.abs(differenceBetweenX)+3)+ 'px';
                svg.style.height = (2*Math.abs(differenceBetweenY)+3)+ 'px';
                svg.appendChild(line);
                connectorSvgs.push(svg);
            }
        }
    });
    // Insert connectors before traitsList so they are underneath
    connectorSvgs.forEach(svg => traitsPanel.insertBefore(svg, traitsList));
    // Now create trait divs (compact, only ID)
    traits.forEach(trait => {
        if (trait[0] === 0) return; // Skip root trait
        const traitDiv = document.createElement('div');
        traitDiv.setAttribute('data-trait-id', trait[0]);
        traitDiv.classList.add('trait');
        const locationMultiplierX = 0.35;
        const locationMultiplierY = 0.35;
        const centerSpot = [500, 350];
        traitDiv.style.position = 'absolute';
        traitDiv.style.left = `${(centerSpot[0] + trait[9])*locationMultiplierX}px`;
        traitDiv.style.top = `${(centerSpot[1] + trait[10])*locationMultiplierY}px`;
        // Add icon image
        const iconImg = document.createElement('img');
        iconImg.src = `Traits/${trait[0]}.png`;
        iconImg.alt = '';
        iconImg.style.width = '23px';
        iconImg.style.height = '23px';
        iconImg.style.display = 'block';
        iconImg.style.boxSizing = 'border-box';
        // Determine if trait is active
        const traitId = trait[0];
        if (typeof selectedTraits !== 'object') window.selectedTraits = {};
        if (selectedTraits[traitId] === undefined) selectedTraits[traitId] = trait[4][0];
        function getStageIdx() {
            return trait[4].findIndex(s => s == selectedTraits[traitId]);
        }
        const isActive = getStageIdx() > 0 && selectedTraits[traitId] !== 'Off' && selectedTraits[traitId] !== 0 && selectedTraits[traitId] !== '0';
        if (isActive) {
            iconImg.style.filter = 'none';
            iconImg.style.border = '1px solid #fff';
        } else {
            iconImg.style.filter = 'grayscale(1) brightness(0.7)';
            iconImg.style.border = '1px solid #000';
        }
        traitDiv.appendChild(iconImg);
        // Add tiny-stages bar
        const tinyStages = document.createElement('div');
        tinyStages.className = 'tiny-stages';
        tinyStages.style.width = '23px';
        tinyStages.style.height = '4px';
        tinyStages.style.display = 'flex';
        tinyStages.style.gap = '3px';
        tinyStages.style.flexDirection = 'row';
        tinyStages.style.background = '#111';
        tinyStages.style.marginTop = '0px';
        tinyStages.style.border = 'none';
        tinyStages.style.justifyContent = 'space-between';
        const stages = trait[4].filter(s => s !== 0 && s !== "0" && s !== "0%" && s !== "Off");
        stages.forEach((stage, idx) => {
            const col = document.createElement('div');
            col.style.flex = '1 1 0';
            col.style.height = '100%';
            col.style.background = (getStageIdx() > idx) ? '#eaff8c' : 'transparent';
            col.style.transition = 'background 0.2s';
            tinyStages.appendChild(col);
        });
        traitDiv.appendChild(tinyStages);
        // Click logic: increment stage if allowed
        traitDiv.onclick = function(e) {
            e.stopPropagation();
            const currentIdx = getStageIdx();
            if (currentIdx < trait[4].length - 1) {
                const reqCheck = checkTraitRequirements(traitId, currentIdx + 1);
                if (!reqCheck.success) {
                    highlightFailedRequirement(reqCheck.failedTraitId);
                    return;
                }
                if (getRemainingTraitPoints() > 0) {
                    selectedTraits[traitId] = trait[4][currentIdx + 1];
                    renderMiniTraitTree();
                    updateStatTable();
                    updateStatTable();
                    if (typeof updateHandSlotColors === 'function') updateHandSlotColors();
                }
            }
        };
        traitDiv.oncontextmenu = function(e) {
            e.preventDefault();
            const currentIdx = getStageIdx();
            if (currentIdx > 0) {
                let canSubtract = true;
                let blockingTraits = [];
                traits.forEach(childTrait => {
                    if ((childTrait[1] === traitId || childTrait[5] === traitId || childTrait[7] === traitId)) {
                        let simulatedStages = { ...selectedTraits };
                        simulatedStages[traitId] = trait[4][currentIdx - 1];
                        let childStageIdx = childTrait[4].findIndex(s => s == selectedTraits[childTrait[0]]);
                        if (childStageIdx > 0) {
                            for (let s = 1; s <= childStageIdx; s++) {
                                let reqCheck = checkTraitRequirementsSim(childTrait[0], s, simulatedStages);
                                if (!reqCheck.success) {
                                    canSubtract = false;
                                    blockingTraits.push(childTrait[0]);
                                    break;
                                }
                            }
                        }
                    }
                });
                if (!canSubtract) {
                    blockingTraits.forEach(highlightFailedRequirement);
                    return;
                }
                selectedTraits[traitId] = trait[4][currentIdx - 1];
                renderMiniTraitTree();
                updateStatTable();
                updateStatTable();
                if (typeof updateHandSlotColors === 'function') updateHandSlotColors();
            }
        };
        // Hover logic: show trait description
        traitDiv.onmouseover = function() {
            showTraitDescription(trait);
        };
        traitDiv.onmouseout = function() {
            clearTraitDescription();
        };
        // Make sure traitDiv uses display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
        traitDiv.style.width = '23px';
        traitDiv.style.height = '29px'; // 23px for icon + 4px for bar + margin
        traitDiv.style.display = 'flex';
        traitDiv.style.flexDirection = 'column';
        traitDiv.style.alignItems = 'center';
        traitDiv.style.justifyContent = 'flex-start';
        container.appendChild(traitDiv);
    });
    panel.appendChild(container);
}
function renderMiniTraitTree() {
    const panel = document.getElementById('traits-panel-mini');
    if (!panel) return;
    panel.innerHTML = '';
    const locationMultiplierX = 0.35;
    const locationMultiplierY = 0.35;
    const centerSpot = [450, 340];
    const container = document.createElement('div');
    container.style.position = 'relative';
    container.style.width = '100%';
    container.style.height = '100%';
    // Draw connectors first
    const connectorSvgs = [];
    traits.forEach(trait => {
        if (trait[0] === 0) return; // Skip root trait
        if (trait[1] > -1) {
            const parentTrait = traits.find(t => t[0] === trait[1]);
            if (parentTrait) {
                const traitX = (centerSpot[0] + trait[9]) * locationMultiplierX + 12;
                const traitY = (centerSpot[1] + trait[10]) * locationMultiplierY + 13;
                const parentX = (centerSpot[0] + parentTrait[9]) * locationMultiplierX + 12;
                const parentY = (centerSpot[1] + parentTrait[10]) * locationMultiplierY + 13;
                let differenceBetweenX = traitX - parentX;
                let differenceBetweenY = traitY - parentY;
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                let startX = 0;
                let startY = 0;
                if(differenceBetweenX < 0){ startX = Math.abs(differenceBetweenX) * 2; }
                if(differenceBetweenY < 0){ startY = Math.abs(differenceBetweenY) * 2; }
                line.setAttribute("x1", startX);
                line.setAttribute("y1", startY);
                line.setAttribute("x2", Math.abs(differenceBetweenX) + 3);
                line.setAttribute("y2", Math.abs(differenceBetweenY) + 3);
                line.setAttribute('stroke', '#444');
                line.setAttribute('stroke-width', '2');
                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                svg.style.position = 'absolute';
                svg.style.left = (traitX-Math.abs(differenceBetweenX))+ 'px';
                svg.style.top = (traitY-Math.abs(differenceBetweenY))+ 'px';
                svg.style.width = (2*Math.abs(differenceBetweenX)+3)+ 'px';
                svg.style.height = (2*Math.abs(differenceBetweenY)+3)+ 'px';
                svg.appendChild(line);
                connectorSvgs.push(svg);
            }
        }
    });
    connectorSvgs.forEach(svg => container.appendChild(svg));
    // Draw trait nodes
    traits.forEach(trait => {
        if (trait[0] === 0) return; // Skip root trait
        const traitDiv = document.createElement('div');
        traitDiv.setAttribute('data-trait-id', trait[0]);
        traitDiv.classList.add('trait');
        traitDiv.style.position = 'absolute';
        traitDiv.style.left = `${(centerSpot[0] + trait[9])*locationMultiplierX}px`;
        traitDiv.style.top = `${(centerSpot[1] + trait[10])*locationMultiplierY}px`;
        // Add icon image
        const iconImg = document.createElement('img');
        iconImg.src = `Traits/${trait[0]}.png`;
        iconImg.alt = '';
        iconImg.style.width = '23px';
        iconImg.style.height = '23px';
        iconImg.style.display = 'block';
        iconImg.style.boxSizing = 'border-box';
        const traitId = trait[0];
        if (typeof selectedTraits !== 'object') window.selectedTraits = {};
        if (selectedTraits[traitId] === undefined) selectedTraits[traitId] = trait[4][0];
        function getStageIdx() {
            return trait[4].findIndex(s => s == selectedTraits[traitId]);
        }
        const isActive = getStageIdx() > 0 && selectedTraits[traitId] !== 'Off' && selectedTraits[traitId] !== 0 && selectedTraits[traitId] !== '0';
        if (isActive) {
            iconImg.style.filter = 'none';
            iconImg.style.border = '1px solid #fff';
        } else {
            iconImg.style.filter = 'grayscale(1) brightness(0.7)';
            iconImg.style.border = '1px solid #000';
        }
        traitDiv.appendChild(iconImg);
        // Add tiny-stages bar
        const tinyStages = document.createElement('div');
        tinyStages.className = 'tiny-stages';
        tinyStages.style.width = '23px';
        tinyStages.style.height = '4px';
        tinyStages.style.display = 'flex';
        tinyStages.style.flexDirection = 'row';
        tinyStages.style.background = '#111';
        tinyStages.style.marginTop = '0px';
        tinyStages.style.border = 'none';
        tinyStages.style.justifyContent = 'space-between';
        const stages = trait[4].filter(s => s !== 0 && s !== "0" && s !== "0%" && s !== "Off");
        stages.forEach((stage, idx) => {
            const col = document.createElement('div');
            col.style.flex = '1 1 0';
            col.style.height = '100%';
            col.style.background = (getStageIdx() > idx) ? '#eaff8c' : 'transparent';
            col.style.transition = 'background 0.2s';
            tinyStages.appendChild(col);
        });
        traitDiv.appendChild(tinyStages);
        // Click logic: increment stage if allowed
        traitDiv.onclick = function(e) {
            e.stopPropagation();
            const currentIdx = getStageIdx();
            if (currentIdx < trait[4].length - 1) {
                const reqCheck = checkTraitRequirements(traitId, currentIdx + 1);
                if (!reqCheck.success) {
                    highlightFailedRequirement(reqCheck.failedTraitId);
                    return;
                }
                if (getRemainingTraitPoints() > 0) {
                    selectedTraits[traitId] = trait[4][currentIdx + 1];
                    renderMiniTraitTree();
                    updateStatTable();
                    updateStatTable();
                    if (typeof updateHandSlotColors === 'function') updateHandSlotColors();
                }
            }
        };
        // Right-click: decrement stage if allowed
        traitDiv.oncontextmenu = function(e) {
            e.preventDefault();
            const currentIdx = getStageIdx();
            if (currentIdx > 0) {
                let canSubtract = true;
                let blockingTraits = [];
                traits.forEach(childTrait => {
                    if ((childTrait[1] === traitId || childTrait[5] === traitId || childTrait[7] === traitId)) {
                        let simulatedStages = { ...selectedTraits };
                        simulatedStages[traitId] = trait[4][currentIdx - 1];
                        let childStageIdx = childTrait[4].findIndex(s => s == selectedTraits[childTrait[0]]);
                        if (childStageIdx > 0) {
                            for (let s = 1; s <= childStageIdx; s++) {
                                let reqCheck = checkTraitRequirementsSim(childTrait[0], s, simulatedStages);
                                if (!reqCheck.success) {
                                    canSubtract = false;
                                    blockingTraits.push(childTrait[0]);
                                    break;
                                }
                            }
                        }
                    }
                });
                if (!canSubtract) {
                    blockingTraits.forEach(highlightFailedRequirement);
                    return;
                }
                selectedTraits[traitId] = trait[4][currentIdx - 1];
                renderMiniTraitTree();
                updateStatTable();
                updateStatTable();
                if (typeof updateHandSlotColors === 'function') updateHandSlotColors();
            }
        };
        // Hover logic: show trait description
        traitDiv.onmouseover = function() {
            showTraitDescription(trait);
        };
        traitDiv.onmouseout = function() {
            clearTraitDescription();
        };
        // Make sure traitDiv uses display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
        traitDiv.style.width = '23px';
        traitDiv.style.height = '29px'; // 23px for icon + 4px for bar + margin
        traitDiv.style.display = 'flex';
        traitDiv.style.flexDirection = 'column';
        traitDiv.style.alignItems = 'center';
        traitDiv.style.justifyContent = 'flex-start';
        container.appendChild(traitDiv);
    });
    panel.appendChild(container);
}

function getStageIndex(traitId) {
    const trait = traits.find(t => t[0] == traitId);
    if (!trait) return 0;
    const currentValue = selectedTraits[traitId];
    return trait[4].findIndex(stage => stage == currentValue);
}

function checkTraitRequirements(traitId, targetStage) {
    const trait = traits.find(t => t[0] == traitId);
    if (!trait) return false;
    let requirementsMet = true;
    let failedTrait = null;
    // Check first requirement
    if (trait[5] !== 0) {
        const req1 = traits.find(t => t[0] == trait[5]);
        if (req1) {
            const req1Stage = getStageIndex(req1[0]);
            if (req1Stage < trait[6]) {
                requirementsMet = false;
                failedTrait = req1[0];
            }
        }
    }
    // Check second requirement
    if (requirementsMet && trait[7] !== 0) {
        const req2 = traits.find(t => t[0] == trait[7]);
        if (req2) {
            const req2Stage = getStageIndex(req2[0]);
            if (req2Stage < trait[8]) {
                requirementsMet = false;
                failedTrait = req2[0];
            }
        }
    }
    // Check parent trait stage
    if (requirementsMet && trait[1] !== 0) {
        const parentTrait = traits.find(t => t[0] == trait[1]);
        if (parentTrait) {
            const parentStage = getStageIndex(parentTrait[0]);
            if (parentStage < targetStage) {
                requirementsMet = false;
                failedTrait = parentTrait[0];
            }
        }
    }
    return {
        success: requirementsMet,
        failedTraitId: failedTrait
    };
}

function checkTraitRequirementsSim(traitId, targetStage, simulatedStages) {
    const trait = traits.find(t => t[0] == traitId);
    if (!trait) return { success: false };
    let requirementsMet = true;
    let failedTrait = null;
    // Check first requirement
    if (trait[5] !== 0) {
        const req1 = traits.find(t => t[0] == trait[5]);
        if (req1) {
            const req1Stage = req1[4].findIndex(stage => stage == simulatedStages[req1[0]]);
            if (req1Stage < trait[6]) {
                requirementsMet = false;
                failedTrait = req1[0];
            }
        }
    }
    // Check second requirement
    if (requirementsMet && trait[7] !== 0) {
        const req2 = traits.find(t => t[0] == trait[7]);
        if (req2) {
            const req2Stage = req2[4].findIndex(stage => stage == simulatedStages[req2[0]]);
            if (req2Stage < trait[8]) {
                requirementsMet = false;
                failedTrait = req2[0];
            }
        }
    }
    // Check parent trait stage
    if (requirementsMet && trait[1] !== 0) {
        const parentTrait = traits.find(t => t[0] == trait[1]);
        if (parentTrait) {
            const parentStage = parentTrait[4].findIndex(stage => stage == simulatedStages[parentTrait[0]]);
            if (parentStage < targetStage) {
                requirementsMet = false;
                failedTrait = parentTrait[0];
            }
        }
    }
    return {
        success: requirementsMet,
        failedTraitId: failedTrait
    };
}
// --- Equipment grid interactivity and item picker ---
let selectedEquipSlot = null;
function setupEquipmentGrid() {
    const itemSlots = document.querySelectorAll('.item-slot');
    itemSlots.forEach(slot => {
        slot.onclick = function() {
            selectedEquipSlot = slot;
            itemSlots.forEach(s => s.classList.remove('selected-equip-slot'));
            slot.classList.add('selected-equip-slot');
            console.log("Selected slot:", slot.getAttribute('data-slot'));
            populateItemPicker(slot.getAttribute('data-slot'));
            updateHandSlotColors();
        };
    });
    patchSimpleItemHover();
}


function populateItemPicker(slotType) {
    const picker = document.querySelector('.upper-col3');
    picker.innerHTML = '';
    const grid = document.createElement('div');
    grid.className = 'selection-grid';
    items.forEach(item => {
        if(item[1] === slotType) {
            const selectionItem = document.createElement('div');
            selectionItem.className = 'selection-item';
            const img = document.createElement('img');
            // Use both name and rarity in alt for correct matching
            const rarity = item[item.length-1] || '';
            img.src = `Items/${item[item.length-2]}`;
            img.alt = `${item[0]};${rarity}`;
            SetImageSize(img);
            img.classList.remove('common', 'uncommon', 'rare', 'epic', 'legendary'); // Remove all rarity classes first
            if(rarity){
                img.classList.add(rarity);
            }
            selectionItem.appendChild(img);
            selectionItem.onclick = function() {
                if(selectedEquipSlot) {
                    let slotImg = selectedEquipSlot.querySelector('img');
                    if(!slotImg) {
                        slotImg = document.createElement('img');
                        selectedEquipSlot.appendChild(slotImg);
                    }
                    slotImg.src = `Items/${item[item.length-2]}`;
                    slotImg.alt = `${item[0]};${rarity}`;
                    slotImg.style.display = 'block';
                    SetImageSize(slotImg);
                    slotImg.classList.remove('common', 'uncommon', 'rare', 'epic', 'legendary');
                    if(rarity){
                        
                        slotImg.classList.add(rarity);
                    }
                    // Debug log for troubleshooting
                    console.log("Chosen item:", item[0]);
                    updateDebug();
                    // Re-attach equipment grid listeners if needed
                    setupEquipmentGrid();
                    updateHandSlotColors();
                }
            };
            grid.appendChild(selectionItem);
        }
    });
    picker.appendChild(grid);
    patchSimpleItemHover();
}
// Patch hover logic for equipment grid and item picker
function patchSimpleItemHover() {
    // Equipment grid
    document.querySelectorAll('.item-slot').forEach(slot => {
        slot.onmouseover = function() {
            const img = slot.querySelector('img');
            if(img && img.alt) {
                const [name, rarity] = img.alt.split(';');
                const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                if(item) showItemName(item);
            }
        };
        slot.onmouseout = clearItemName;
    });
    // Item picker
    document.querySelectorAll('.selection-item').forEach(sel => {
        sel.onmouseover = function() {
            const img = sel.querySelector('img');
            if(img && img.alt) {
                const [name, rarity] = img.alt.split(';');
                const item = items.find(i => i[0] === name && (i[i.length-1] === rarity || (!i[i.length-1] && !rarity)));
                if(item) showItemName(item);
            }
        };
        sel.onmouseout = clearItemName;
    });
}
// Patch right-click to clear item slot
function patchItemSlotRightClick() {
    document.querySelectorAll('.item-slot').forEach(slot => {
        slot.oncontextmenu = function(e) {
            e.preventDefault();
            slot.innerHTML = '';
            if (typeof updateStatTable === 'function') updateStatTable();
            if (typeof updateHandSlotColors === 'function') updateHandSlotColors();
            if (typeof clearItemName === 'function') clearItemName();
            updateStatTable();
        };
    });
}
window.addEventListener('DOMContentLoaded', function() {
    setupEquipmentGrid();
    patchItemSlotRightClick();
});
</script>
<script>
function showItemName(item) { //Show item description
    const descCell = document.querySelector('.upper-col2-row1-desc');
    if (!descCell || !item) return;
    // Build description
    const rarity = item[item.length-1] || '';
    let titleColor = '#fff';
    switch(rarity) {
        case 'common':
            titleColor = '#fff';
            break;
        case 'uncommon':
            titleColor = '#23ff2e';
            break;
        case 'rare':
            titleColor = '#00ccff';
            break;
        case 'epic':
            titleColor = '#f712eb';
            break;
        case 'legendary':
            titleColor = '#ffee01';
            break;
    }
    let html = `<span style="font-weight: bold; color: ${titleColor}">${item[0]}</span><br>`;
    if(item[16]) html += `${item[16]}<br>`;
    if(item[2]) html += `Type: ${item[2]}<br>`;
    // List of stat fields to check and display
    const statFields = [
        { label: 'Ability', idx: 8 },
        { label: 'Magic', idx: 9 },
        { label: 'Armor', idx: 10 },
        { label: 'Defense', idx: 11 },
        { label: 'Move Speed', idx: 12 },
        { label: 'Attack Speed', idx: 13 },
        { label: 'HP', idx: 6 },
        { label: 'Mana', idx: 7 },
        { label: 'Damage', idx: 5 },
        { label: 'Range', idx: 4 },
        { label: 'Equip Size', idx: 15 }
    ];
    statFields.forEach(f => {
        const val = item[f.idx];
        if(val && !isNaN(val) && Number(val) !== 0) {
            let valueColor = '#fff';
            if(val < 0){
                valueColor = '#ff0000'; // Negative values in red
            } else if(val > 0){
                valueColor = '#00ff00'; // Positive values in green
            } else {
                valueColor = '#faf'; // Default color for zero or neutral values
            }
            html += `${f.label}: <span style="color: ${valueColor}">${val}</span><br>`;
        }
    });
    if(item[3] && !isNaN(item[3])) {
        html += `It weighs ${(item[3]/10).toFixed(2)} oz.<br>`;
    }
    // Show rarity if present
    if(rarity) html += `<span style="color: ${titleColor}">[${rarity}]</span>`;
    descCell.innerHTML = html;
}
function clearItemName() {
    const descCell = document.querySelector('.upper-col2-row1-desc');
    if (descCell) descCell.innerHTML = '';
}
function showTraitDescription(trait) {
    const descCell = document.querySelector('.upper-col2-row1-desc');
    if (!descCell || !trait) return;
    let html = `<div style="text-align: center;">${trait[2]}<br>${trait[3]}<br><br>`;
    if (trait[4] && trait[4].length > 1) {
        let currentStage = 0;
        trait[4].forEach((stage, idx) => {
            //if (stage !== 0 && stage !== '0' && stage !== '0%' && stage !== 'Off') {
            //Check what stage of this trait is selected
            currentStage = selectedTraits[trait[0]];
            if (currentStage === stage) {
                html += `<div class="active-stage-desc">${stage}</div> `;
            } else {
                html += `<div class="inactive-stage-desc">${stage}</div> `;
            }
            //    html += `<span style='color:#eaff8c'>${stage}</span> `;
            //}
        });
    }
    html += `</div>`;
    descCell.innerHTML = html;
}
function clearTraitDescription() {
    const descCell = document.querySelector('.upper-col2-row1-desc');
    if (descCell) descCell.innerHTML = '';
}
// Call patchSimpleItemHover after populating equipment grid and item picker
function setupEquipmentGrid() {
    const itemSlots = document.querySelectorAll('.item-slot');
    itemSlots.forEach(slot => {
        slot.onclick = function() {
            selectedEquipSlot = slot;
            itemSlots.forEach(s => s.classList.remove('selected-equip-slot'));
            slot.classList.add('selected-equip-slot');
            console.log("Selected slot:", slot.getAttribute('data-slot'));
            populateItemPicker(slot.getAttribute('data-slot'));
            updateHandSlotColors();
            updateStatTable();
        };
    });
    patchSimpleItemHover();
}
function populateItemPicker(slotType) {
    const picker = document.querySelector('.upper-col3');
    picker.innerHTML = '';
    const grid = document.createElement('div');
    grid.className = 'selection-grid';
    items.forEach(item => {
        if(item[1] === slotType) {
            const selectionItem = document.createElement('div');
            selectionItem.className = 'selection-item';
            const img = document.createElement('img');
            // Use both name and rarity in alt for correct matching
            const rarity = item[item.length-1] || '';
            img.src = `Items/${item[item.length-2]}`;
            img.alt = `${item[0]};${rarity}`;
            SetImageSize(img);
            img.classList.remove('common', 'uncommon', 'rare', 'epic', 'legendary');
            if(rarity){
                img.classList.add(rarity);
            }
            selectionItem.appendChild(img);
            selectionItem.onclick = function() {
                if(selectedEquipSlot) {
                    let slotImg = selectedEquipSlot.querySelector('img');
                    if(!slotImg) {
                        slotImg = document.createElement('img');
                        selectedEquipSlot.appendChild(slotImg);
                    }
                    slotImg.src = `Items/${item[item.length-2]}`;
                    slotImg.alt = `${item[0]};${rarity}`;
                    slotImg.style.display = 'block';
                    SetImageSize(slotImg);
                        slotImg.classList.remove('common', 'uncommon', 'rare', 'epic', 'legendary');
                    if(rarity){
                        slotImg.classList.add(rarity);
                    }
                    // Debug log for troubleshooting
                    console.log("Chosen item:", item[0]);
                    updateDebug();
                    // Re-attach equipment grid listeners if needed
                    setupEquipmentGrid();
                    updateHandSlotColors();
                }
            };
            grid.appendChild(selectionItem);
        }
    });
    picker.appendChild(grid);
    patchSimpleItemHover();
}
</script>
<script>
// Patch: Show <marquee> content in Description cell on hover
function patchMarqueeHover() {
    document.querySelectorAll('.stat-container marquee').forEach(marq => {
        marq.onmouseover = function() {
            const descCell = document.querySelector('.upper-col2-row1-desc');
            if (descCell) descCell.innerHTML = marq.textContent;
        };
        marq.onmouseout = function() {
            const descCell = document.querySelector('.upper-col2-row1-desc');
            if (descCell) descCell.innerHTML = '';
        };
    });
}
// Ensure this runs after stat table is updated
const origUpdateStatTable3 = updateStatTable;
updateStatTable = function() {
    if (typeof origUpdateStatTable3 === 'function') origUpdateStatTable3();
    patchMarqueeHover();
    if (typeof updateHandSlotColors === 'function') updateHandSlotColors();
};
</script>
<script>
function highlightFailedRequirement(traitId) {
    const traitDiv = document.querySelector(`.trait[data-trait-id="${traitId}"]`);
    if (traitDiv) {
        traitDiv.classList.add('requirement-error');
        setTimeout(() => {
            traitDiv.classList.remove('requirement-error');
        }, 1000);
    }
}

</script>
<script>
function getAvailableTraitPoints(level) {
    return Math.floor((level) / 2);
}
function getUsedTraitPoints() {
    let used = 0;
    for (const traitId in selectedTraits) {
        const trait = traits.find(t => t[0] == traitId);
        if (trait) {
            const idx = trait[4].findIndex(s => s == selectedTraits[traitId]);
            if (idx > 0) used += idx;
        }
    }
    return used;
}
function getRemainingTraitPoints() {
    return getAvailableTraitPoints(selectedLevel) - getUsedTraitPoints();
}
</script>
<script>
function updateHandSlotColors() {
    // Find all hand slots (assume first and second .item-slot[data-slot="hand"])
    const handSlots = document.querySelectorAll('.item-slot[data-slot="hand"]');
    if (handSlots.length < 2) return;
    const leftHandSlot = handSlots[0];
    const rightHandSlot = handSlots[1];
    const leftHandImg = leftHandSlot.querySelector('img');
    const rightHandImg = rightHandSlot.querySelector('img');
    const leftHandItem = leftHandImg ? items.find(i => i[0] === leftHandImg.alt.split(";")[0]) : null;
    const rightHandItem = rightHandImg ? items.find(i => i[0] === rightHandImg.alt.split(";")[0]) : null;
    let leftHandSize = leftHandItem ? leftHandItem[15] || 0 : 0;
    let rightHandSize = rightHandItem ? rightHandItem[15] || 0 : 0;
    //console.log(leftHandSize+" + " + rightHandSize+ " = " + (leftHandSize + rightHandSize));
    // Trait 20: Dual-wielding
    const dualWieldingTrait = selectedTraits["20"];
    let dualWieldingActive = false;
    if (dualWieldingTrait && dualWieldingTrait !== 0 && dualWieldingTrait !== "0" && dualWieldingTrait !== "Off") {
        dualWieldingActive = true;
        // If size 6, treat as 5
        if (leftHandSize == 6) leftHandSize = 5;
        if (rightHandSize == 6) rightHandSize = 5;
    }
    const totalSize = leftHandSize + rightHandSize;
    if (totalSize > 10) {
        leftHandSlot.classList.add('invalid');
        rightHandSlot.classList.add('invalid');
    } else {
        leftHandSlot.classList.remove('invalid');
        rightHandSlot.classList.remove('invalid');
    }
}
</script>
